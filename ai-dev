#!/bin/bash

# ai-dev - A CLI wrapper for the AI Development Framework
# This script provides a user-friendly interface to the underlying .md workflows.
# Version: 2.0 - Enhanced with robust validation and new commands

set -euo pipefail  # Exit on error, undefined vars, pipe failures

# --- Global Variables ---
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly AI_WORKFLOW_DIR="${SCRIPT_DIR}/.ai_workflow"
readonly CACHE_DIR="${AI_WORKFLOW_DIR}/cache"
readonly CONFIG_FILE="${AI_WORKFLOW_DIR}/config/framework.json"
readonly LOG_FILE="${CACHE_DIR}/ai-dev.log"

# Ensure directories exist
mkdir -p "${CACHE_DIR}"
mkdir -p "${AI_WORKFLOW_DIR}/config"
mkdir -p "${AI_WORKFLOW_DIR}/logs"

# Colors for output
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly NC='\033[0m' # No Color

# --- Utility Functions ---
log() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') [INFO] $*" >> "$LOG_FILE"
}

error() {
    echo -e "${RED}Error: $*${NC}" >&2
    echo "$(date '+%Y-%m-%d %H:%M:%S') [ERROR] $*" >> "$LOG_FILE"
}

warning() {
    echo -e "${YELLOW}Warning: $*${NC}" >&2
    echo "$(date '+%Y-%m-%d %H:%M:%S') [WARNING] $*" >> "$LOG_FILE"
}

success() {
    echo -e "${GREEN}$*${NC}"
    echo "$(date '+%Y-%m-%d %H:%M:%S') [SUCCESS] $*" >> "$LOG_FILE"
}

info() {
    echo -e "${BLUE}$*${NC}"
    echo "$(date '+%Y-%m-%d %H:%M:%S') [INFO] $*" >> "$LOG_FILE"
}

# --- Validation Functions ---
validate_environment() {
    log "Validating environment"
    
    # Create necessary directories
    mkdir -p "$CACHE_DIR" "$AI_WORKFLOW_DIR/config" "$AI_WORKFLOW_DIR/logs"
    
    # Check if we're in a valid AI framework directory
    if [ ! -d "$AI_WORKFLOW_DIR" ]; then
        error "Not in an AI Development Framework directory"
        error "Expected to find .ai_workflow/ directory"
        exit 1
    fi
    
    # Check for required workflow directories
    local required_dirs=(
        "workflows/setup"
        "workflows/run" 
        "workflows/security"
        "workflows/quality"
        "workflows/monitoring"
    )
    
    for dir in "${required_dirs[@]}"; do
        if [ ! -d "${AI_WORKFLOW_DIR}/${dir}" ]; then
            warning "Missing workflow directory: ${dir}"
        fi
    done
    
    # Check for critical files
    if [ ! -f "${AI_WORKFLOW_DIR}/GLOBAL_AI_RULES.md" ]; then
        warning "Missing GLOBAL_AI_RULES.md - framework may not function correctly"
    fi
    
    # Validate permissions
    if [ ! -w "$CACHE_DIR" ]; then
        error "No write permission to cache directory: $CACHE_DIR"
        exit 1
    fi
    
    log "Environment validation completed"
}

# Auto-install pre-commit system (zero friction)
auto_install_precommit() {
    log "Checking pre-commit system auto-installation"
    
    # Check if we're in a git repository
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        log "Not in a git repository, skipping pre-commit auto-installation"
        return 0
    fi
    
    local git_hooks_dir="$(git rev-parse --git-dir)/hooks"
    local framework_hooks_dir="$AI_WORKFLOW_DIR/precommit/hooks"
    local config_file="$AI_WORKFLOW_DIR/precommit/config/validation_rules.json"
    
    # Check if hooks are already installed
    if [ -f "$git_hooks_dir/pre-commit" ] && [ -f "$config_file" ]; then
        log "Pre-commit system already installed"
        return 0
    fi
    
    log "Auto-installing pre-commit system (zero friction mode)"
    
    # Create default configuration if not exists
    if [ ! -f "$config_file" ]; then
        mkdir -p "$(dirname "$config_file")"
        cat > "$config_file" << 'EOF'
{
  "validation_rules": {
    "code_quality": {
      "enabled": true,
      "max_complexity": 10,
      "max_function_lines": 50,
      "require_documentation": false,
      "check_bash_syntax": true,
      "validate_markdown": true,
      "check_json_yaml": true
    },
    "security": {
      "enabled": true,
      "block_sensitive_data": true,
      "require_secure_paths": true,
      "scan_dependencies": true,
      "check_permissions": true,
      "validate_commands": true
    },
    "framework_compliance": {
      "enabled": true,
      "require_claude_md_updates": false,
      "validate_workflow_structure": true,
      "check_integration_tests": false,
      "enforce_naming_conventions": true,
      "validate_todo_updates": false
    },
    "documentation": {
      "enabled": false,
      "sync_readme": false,
      "validate_comments": false,
      "check_changelog": false,
      "require_examples": false
    }
  },
  "quality_gates": {
    "minimum_score": 80,
    "block_on_security_issues": true,
    "block_on_critical_errors": true,
    "allow_override": false,
    "require_manual_review": false
  },
  "file_patterns": {
    "include": [
      "*.sh",
      "*.md",
      "*.json",
      "*.yml",
      "*.yaml",
      "ai-dev"
    ],
    "exclude": [
      ".git/**",
      ".ai_workflow/cache/**",
      ".ai_workflow/logs/**",
      "*.log",
      "*.tmp",
      "capturas/**",
      "*.png",
      "*.jpg",
      "*.jpeg",
      "*.gif"
    ]
  },
  "hooks": {
    "pre_commit": {
      "enabled": true,
      "timeout_seconds": 30,
      "fail_fast": true
    },
    "pre_push": {
      "enabled": false,
      "timeout_seconds": 60,
      "additional_checks": true
    },
    "commit_msg": {
      "enabled": false,
      "enforce_conventional_commits": true,
      "max_length": 100
    }
  },
  "metadata": {
    "created": "$(date -u +"%Y-%m-%dT%H:%M:%S.%3NZ")",
    "framework_version": "v0.4.0-beta",
    "configuration_version": "1.0",
    "auto_installed": true
  }
}
EOF
        log "Default pre-commit configuration created"
    fi
    
    # Install hooks silently if framework hooks exist
    if [ -d "$framework_hooks_dir" ]; then
        local hooks_installed=0
        
        # Backup existing hooks silently
        local backup_dir="$AI_WORKFLOW_DIR/precommit/backup_hooks_$(date +%Y%m%d_%H%M%S)"
        mkdir -p "$backup_dir"
        
        for hook in pre-commit pre-push commit-msg; do
            if [ -f "$git_hooks_dir/$hook" ]; then
                cp "$git_hooks_dir/$hook" "$backup_dir/" 2>/dev/null || true
            fi
        done
        
        # Install framework hooks silently
        for hook in pre-commit pre-push commit-msg; do
            if [ -f "$framework_hooks_dir/$hook" ]; then
                cp "$framework_hooks_dir/$hook" "$git_hooks_dir/" 2>/dev/null || true
                chmod +x "$git_hooks_dir/$hook" 2>/dev/null || true
                hooks_installed=$((hooks_installed + 1))
            fi
        done
        
        if [ $hooks_installed -gt 0 ]; then
            log "Pre-commit hooks auto-installed silently ($hooks_installed hooks)"
            
            # Create installation marker
            echo "$(date -u +"%Y-%m-%dT%H:%M:%S.%3NZ")" > "$AI_WORKFLOW_DIR/precommit/.auto_installed"
            
            # Log successful installation
            echo "Auto-installed pre-commit system with $hooks_installed hooks" >> "$AI_WORKFLOW_DIR/logs/precommit_auto_install.log"
        else
            log "No hooks found to install"
        fi
    else
        log "Framework hooks directory not found, skipping auto-installation"
    fi
}

validate_file_path() {
    local file_path="$1"
    local file_type="${2:-file}"
    
    # Security: Prevent symbolic link following (check first)
    if [ -L "$file_path" ]; then
        error "Symbolic links not allowed: $file_path"
        return 1
    fi
    
    # Security: Prevent path traversal attacks
    if [[ "$file_path" == *".."* ]] || [[ "$file_path" == *"~"* ]]; then
        error "Invalid file path: Path traversal not allowed"
        return 1
    fi
    
    # Security: Prevent absolute path access to system files
    if [[ "$file_path" == /* ]]; then
        error "Absolute paths not allowed: $file_path"
        return 1
    fi
    
    # Check if file exists
    if [ ! -f "$file_path" ]; then
        error "File not found: $file_path"
        return 1
    fi
    
    # Check file extension for specific types
    case "$file_type" in
        "prd")
            if [[ "$file_path" != *.md ]]; then
                error "PRD file must be a markdown file (.md)"
                return 1
            fi
            ;;
        "prp")
            if [[ "$file_path" != *.md ]]; then
                error "PRP file must be a markdown file (.md)"
                return 1
            fi
            ;;
    esac
    
    # Check file readability
    if [ ! -r "$file_path" ]; then
        error "Cannot read file: $file_path"
        return 1
    fi
    
    log "File validation passed: $file_path"
    return 0
}

check_dependencies() {
    local missing_deps=()
    
    # Check for required commands
    local required_commands=("bash" "mkdir" "touch" "grep" "find")
    
    for cmd in "${required_commands[@]}"; do
        if ! command -v "$cmd" >/dev/null 2>&1; then
            missing_deps+=("$cmd")
        fi
    done
    
    if [ ${#missing_deps[@]} -gt 0 ]; then
        error "Missing required dependencies: ${missing_deps[*]}"
        error "Please install missing dependencies and try again"
        exit 1
    fi
    
    log "Dependencies check passed"
}

# --- Enhanced Help Function ---
show_help() {
    cat << EOF
${BLUE}AI Development Framework CLI v2.0${NC}

${GREEN}Usage:${NC} ./ai-dev <command> [options]

${GREEN}Core Commands:${NC}
  setup                    Start the interactive project setup workflow
  generate <prd_file>      Generate tasks from a Product Requirements Document
  run <prp_file>           Execute a Project-Response-Plan file
  optimize <prompt_file>   Optimize a prompt file using best practices

${GREEN}New Commands:${NC}
  audit                    Run comprehensive security audit
  sync                     Synchronize with framework updates
  configure [options]      Configure framework settings
  diagnose                 Diagnose framework health and status
  quality <path>           Run quality validation on project
  precommit <subcommand>   Pre-commit validation and quality assurance

${GREEN}Utility Commands:${NC}
  help                     Show this help message
  version                  Show framework version information
  status                   Show current framework status

${GREEN}Options:${NC}
  --verbose, -v           Enable verbose output
  --quiet, -q             Suppress non-error output
  --dry-run               Show what would be done without executing
  --force                 Force execution (bypass some validations)

${GREEN}Examples:${NC}
  ./ai-dev setup
  ./ai-dev generate docs/prd.md
  ./ai-dev run .ai_workflow/PRPs/generated/prp-feature.md
  ./ai-dev optimize .ai_workflow/generate-tasks.md
  ./ai-dev quality src/
  ./ai-dev audit --verbose
  ./ai-dev configure --user
  ./ai-dev diagnose

${GREEN}Configuration:${NC}
  Framework config: ${CONFIG_FILE}
  Logs location: ${LOG_FILE}
  Cache location: ${CACHE_DIR}

For more information, visit: https://github.com/your-org/ai-framework
EOF
}

# --- Option Parsing ---
VERBOSE=false
QUIET=false
DRY_RUN=false
FORCE=false

# Parse global options
while [[ $# -gt 0 ]]; do
    case $1 in
        -v|--verbose)
            VERBOSE=true
            shift
            ;;
        -q|--quiet)
            QUIET=true
            shift
            ;;
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        --force)
            FORCE=true
            shift
            ;;
        --)
            shift
            break
            ;;
        -*)
            error "Unknown option: $1"
            show_help
            exit 1
            ;;
        *)
            break
            ;;
    esac
done

# --- Workflow Calling Functions ---

# Universal workflow calling function
call_workflow() {
    local workflow_path="$1"
    shift
    local workflow_args="$*"
    
    # Resolve full path
    local full_path="${AI_WORKFLOW_DIR}/workflows/${workflow_path}"
    
    if [ ! -f "$full_path" ]; then
        error "Workflow not found: $workflow_path"
        return 1
    fi
    
    # Export arguments for the called workflow
    export WORKFLOW_ARGS="$workflow_args"
    
    [ "$VERBOSE" = "true" ] && info "Calling workflow: $workflow_path with args: $workflow_args"
    
    # Execute the workflow using our MD parser
    execute_md_workflow "$full_path"
}

# Error handling function
handle_workflow_error() {
    local error_message="$1"
    [ "$VERBOSE" = "true" ] && info "Handling workflow error: $error_message"
    export WORKFLOW_ARGS="$error_message"
    call_workflow "common/error.md" "$error_message"
}

# Logging function
log_workflow_event() {
    local log_level="$1"
    local log_message="$2"
    [ "$VERBOSE" = "true" ] && info "Logging workflow event: $log_level - $log_message"
    export WORKFLOW_ARGS="$log_level $log_message"
    call_workflow "common/log_work_journal.md" "$log_level" "$log_message"
}

# State management function
manage_workflow_state() {
    local action="${1:-get}"
    local state_data="${2:-}"
    [ "$VERBOSE" = "true" ] && info "Managing workflow state: $action $state_data"
    export WORKFLOW_ARGS="$action $state_data"
    call_workflow "common/manage_workflow_state.md" "$action" "$state_data"
}

# Success handling
handle_workflow_success() {
    local success_message="${1:-Workflow completed successfully}"
    [ "$VERBOSE" = "true" ] && info "Handling workflow success: $success_message"
    export WORKFLOW_ARGS="$success_message"
    call_workflow "common/success.md" "$success_message"
}

# Rollback function
rollback_workflow_changes() {
    local rollback_reason="${1:-Rollback requested}"
    [ "$VERBOSE" = "true" ] && info "Rolling back workflow changes: $rollback_reason"
    export WORKFLOW_ARGS="$rollback_reason"
    call_workflow "common/rollback_changes.md" "$rollback_reason"
}

# Execute abstract tool function
execute_abstract_tool() {
    local tool_name="$1"
    shift
    local tool_args="$*"
    [ "$VERBOSE" = "true" ] && info "Executing abstract tool: $tool_name with args: $tool_args"
    export WORKFLOW_ARGS="$tool_name $tool_args"
    call_workflow "tools/execute_abstract_tool_call.md" "$tool_name" "$tool_args"
}

# Process workflow calls within bash content
process_workflow_calls() {
    local bash_content="$1"
    local processed_content="$bash_content"
    
    # Replace direct workflow execution calls
    processed_content=$(echo "$processed_content" | sed -E 's|\./\.ai_workflow/workflows/([^/]+)/([^/]+)\.md|call_workflow "\1/\2.md"|g')
    
    # Replace source workflow calls  
    processed_content=$(echo "$processed_content" | sed -E 's|source \.ai_workflow/workflows/([^/]+)/([^/]+)\.md|call_workflow "\1/\2.md"|g')
    
    # Replace bash workflow calls
    processed_content=$(echo "$processed_content" | sed -E 's|bash \.ai_workflow/workflows/([^/]+)/([^/]+)\.md|call_workflow "\1/\2.md"|g')
    
    # Replace common error pattern
    processed_content=$(echo "$processed_content" | sed -E 's|\./\.ai_workflow/workflows/common/error\.md "([^"]+)"|handle_workflow_error "\1"|g')
    
    # Replace common logging pattern
    processed_content=$(echo "$processed_content" | sed -E 's|\./\.ai_workflow/workflows/common/log_work_journal\.md "([^"]+)" "([^"]+)"|log_workflow_event "\1" "\2"|g')
    
    echo "$processed_content"
}

# --- Main Logic ---
COMMAND=${1:-}

# Show help if no command is provided
if [ -z "$COMMAND" ]; then
    error "No command provided"
    show_help
    exit 1
fi

# Shift to process arguments for the specific command
shift

# Initialize environment (always run basic validation)
# CLI initialization message will be printed after command-specific flag parsing

# Run validation unless bypassed
if [ "$FORCE" != "true" ]; then
    check_dependencies
    validate_environment
    auto_install_precommit
fi

# Execute workflow with error handling
execute_workflow() {
    local workflow_path="$1"
    local description="$2"
    
    if [ ! -f "$workflow_path" ]; then
        error "Workflow not found: $workflow_path"
        exit 1
    fi
    
    if [ "$DRY_RUN" = "true" ]; then
        info "DRY RUN: Would execute: $description"
        info "Workflow: $workflow_path"
        return 0
    fi
    
    info "Executing: $description"
    log "Executing workflow: $workflow_path"
    
    # Parse and execute markdown workflow
    if ! execute_md_workflow "$workflow_path"; then
        error "Workflow execution failed: $workflow_path"
        error "Run with --verbose for detailed output"
        exit 1
    fi
    
    success "Completed: $description"
}

# Parse and execute markdown workflow - Native bash implementation
execute_md_workflow() {
    local workflow_file="$1"
    local temp_script="/tmp/ai_workflow_$$.sh"
    local in_bash_block=false
    local bash_content=""
    local line_num=0
    local blocks_executed=0
    
    # Check if file is empty
    if [ ! -s "$workflow_file" ]; then
        warning "Empty workflow file: $workflow_file"
        return 0
    fi
    
    # Extract bash code blocks from markdown
    while IFS= read -r line; do
        line_num=$((line_num + 1))
        
        # Detect start of bash code block
        if [[ "$line" =~ ^\`\`\`bash$ ]]; then
            in_bash_block=true
            bash_content=""
            [ "$VERBOSE" = "true" ] && echo "Found bash block at line $line_num"
            continue
        fi
        
        # Detect end of code block
        if [[ "$line" =~ ^\`\`\`$ ]] && [ "$in_bash_block" = true ]; then
            in_bash_block=false
            blocks_executed=$((blocks_executed + 1))
            
            # Process workflow calls in bash content
            bash_content=$(process_workflow_calls "$bash_content")
            
            # Create temporary script with the processed bash code
            echo "#!/bin/bash" > "$temp_script"
            echo "set -euo pipefail" >> "$temp_script"
            echo "# Extracted from $workflow_file - Block $blocks_executed" >> "$temp_script"
            echo "" >> "$temp_script"
            echo "# Framework function context injection" >> "$temp_script"
            echo "call_workflow() { $(declare -f call_workflow | tail -n +2); }" >> "$temp_script"
            echo "manage_workflow_state() { $(declare -f manage_workflow_state | tail -n +2); }" >> "$temp_script"
            echo "log_workflow_event() { $(declare -f log_workflow_event | tail -n +2); }" >> "$temp_script"
            echo "execute_abstract_tool() { $(declare -f execute_abstract_tool | tail -n +2); }" >> "$temp_script"
            echo "handle_workflow_error() { $(declare -f handle_workflow_error | tail -n +2); }" >> "$temp_script"
            echo "execute_md_workflow() { $(declare -f execute_md_workflow | tail -n +2); }" >> "$temp_script"
            echo "process_workflow_calls() { $(declare -f process_workflow_calls | tail -n +2); }" >> "$temp_script"
            echo "info() { $(declare -f info | tail -n +2); }" >> "$temp_script"
            echo "warning() { $(declare -f warning | tail -n +2); }" >> "$temp_script"
            echo "error() { $(declare -f error | tail -n +2); }" >> "$temp_script"
            echo "success() { $(declare -f success | tail -n +2); }" >> "$temp_script"
            echo "" >> "$temp_script"
            echo "# Workflow content:" >> "$temp_script"
            printf "%s" "$bash_content" >> "$temp_script"
            chmod +x "$temp_script"
            
            [ "$VERBOSE" = "true" ] && echo "Executing bash block $blocks_executed..."
            
            # Execute the extracted bash code using source to preserve function context
            if [ "$VERBOSE" = "true" ]; then
                echo "--- Executing bash block $blocks_executed ---"
                cat "$temp_script"
                echo "--- End of bash block $blocks_executed ---"
                source "$temp_script" || {
                    error "Failed executing bash block $blocks_executed in $workflow_file"
                    error "Script content was:"
                    cat "$temp_script"
                    rm -f "$temp_script"
                    return 1
                }
            else
                source "$temp_script" 2>/dev/null || {
                    error "Failed executing bash block $blocks_executed in $workflow_file"
                    error "Run with --verbose for detailed output"
                    rm -f "$temp_script"
                    return 1
                }
            fi
            
            # Clean up temporary script
            rm -f "$temp_script"
            continue
        fi
        
        # Collect bash code lines
        if [ "$in_bash_block" = true ]; then
            bash_content="${bash_content}${line}
"
        fi
        
    done < "$workflow_file"
    
    # Check for unclosed bash blocks
    if [ "$in_bash_block" = true ]; then
        error "Unclosed bash block detected in $workflow_file"
        rm -f "$temp_script"
        return 1
    fi
    
    [ "$VERBOSE" = "true" ] && echo "Successfully executed $blocks_executed bash blocks from $workflow_file"
    
    # Clean up any remaining temp files
    rm -f "$temp_script"
    
    return 0
}

# Command routing with enhanced validation
case "$COMMAND" in
    setup)
        # Handle help option for setup command
        if [[ "${1:-}" == "--help" ]] || [[ "${1:-}" == "-h" ]]; then
            cat << EOF
${BLUE}Setup Command Help${NC}

${GREEN}Usage:${NC} ./ai-dev setup

${GREEN}Description:${NC}
Start the interactive project setup workflow. This command initializes a new AI Development 
Framework project by creating the necessary directory structure, configuration files, and 
setting up the development environment.

${GREEN}What it does:${NC}
- Creates .ai_workflow directory structure
- Initializes configuration files
- Sets up project templates
- Configures git repository (if needed)
- Validates framework installation

${GREEN}Examples:${NC}
  ./ai-dev setup              # Start interactive setup
  ./ai-dev setup --help       # Show this help

${GREEN}Note:${NC} This command requires write permissions in the current directory.
EOF
            exit 0
        fi
        
        if [ "$QUIET" != "true" ]; then
            info "AI Development Framework CLI v2.0"
        fi
        info "Starting project setup workflow"
        execute_workflow "${AI_WORKFLOW_DIR}/workflows/setup/01_start_setup.md" "Project Setup"
        ;;

    generate)
        PRD_FILE=${1:-}
        if [ -z "$PRD_FILE" ]; then
            error "Missing required argument: <prd_file>"
            show_help
            exit 1
        fi
        
        validate_file_path "$PRD_FILE" "prd"
        
        info "Generating tasks from: $PRD_FILE"
        export PRD_FILE_PATH="$PRD_FILE"
        execute_workflow "${AI_WORKFLOW_DIR}/generate-tasks.md" "Task Generation"
        ;;

    run)
        PRP_FILE=${1:-}
        if [ -z "$PRP_FILE" ]; then
            error "Missing required argument: <prp_file>"
            show_help
            exit 1
        fi
        
        validate_file_path "$PRP_FILE" "prp"
        
        info "Executing PRP: $PRP_FILE"
        export PRP_FILE_PATH="$PRP_FILE"
        
        # Execute the PRP file directly using the markdown parser
        if [ "$DRY_RUN" = "true" ]; then
            info "DRY RUN: Would execute PRP file: $PRP_FILE"
            return 0
        fi
        
        info "Parsing and executing PRP file: $PRP_FILE"
        log "Executing PRP file: $PRP_FILE"
        
        # Use the native markdown parser to execute the PRP file
        if ! execute_md_workflow "$PRP_FILE"; then
            error "PRP execution failed: $PRP_FILE"
            error "Run with --verbose for detailed output"
            exit 1
        fi
        
        success "PRP execution completed: $PRP_FILE"
        ;;

    optimize)
        # Process optimize-specific flags
        prompt_file=""
        for arg in "$@"; do
            case $arg in
                -v|--verbose)
                    VERBOSE=true
                    ;;
                -q|--quiet)
                    QUIET=true
                    ;;
                --dry-run)
                    DRY_RUN=true
                    ;;
                --force)
                    FORCE=true
                    ;;
                -*)
                    # Skip other flags
                    ;;
                *)
                    # This should be the prompt file
                    if [ -z "$prompt_file" ]; then
                        prompt_file="$arg"
                    fi
                    ;;
            esac
        done
        
        PROMPT_FILE="$prompt_file"
        if [ -z "$PROMPT_FILE" ]; then
            error "Missing required argument: <prompt_file>"
            show_help
            exit 1
        fi
        
        validate_file_path "$PROMPT_FILE"
        
        if [ "$DRY_RUN" = "true" ]; then
            info "DRY RUN: Would optimize prompt file: $PROMPT_FILE"
            exit 0
        fi
        
        info "Optimizing prompt: $PROMPT_FILE"
        export PROMPT_FILE_PATH="$PROMPT_FILE"
        execute_workflow "${AI_WORKFLOW_DIR}/workflows/monitoring/optimize_prompts.md" "Prompt Optimization"
        ;;

    audit)
        info "Running comprehensive security audit"
        execute_workflow "${AI_WORKFLOW_DIR}/workflows/security/audit_security.md" "Security Audit"
        ;;

    sync)
        info "Synchronizing with framework updates"
        if [ -f "${AI_WORKFLOW_DIR}/workflows/sync/sync_framework_updates.md" ]; then
            execute_workflow "${AI_WORKFLOW_DIR}/workflows/sync/sync_framework_updates.md" "Framework Sync"
        else
            warning "Sync workflow not yet implemented"
            info "This feature will be available in the next phase"
        fi
        ;;

    configure)
        # Handle help option for configure command
        if [[ "${1:-}" == "--help" ]] || [[ "${1:-}" == "-h" ]]; then
            cat << EOF
${BLUE}Configure Command Help${NC}

${GREEN}Usage:${NC} ./ai-dev configure [options]

${GREEN}Description:${NC}
Configure framework settings and preferences. This command allows you to customize
the AI Development Framework behavior, set default values, and manage configuration
files across your development environment.

${GREEN}Options:${NC}
  --user                Configure user-specific settings
  --system              Configure system-wide settings  
  --reset               Reset configuration to defaults
  --show                Show current configuration
  --help, -h            Show this help

${GREEN}What it does:${NC}
- Configure framework preferences
- Set default command options
- Manage environment settings
- Validate configuration files
- Set up integrations

${GREEN}Examples:${NC}
  ./ai-dev configure              # Interactive configuration
  ./ai-dev configure --user       # Configure user settings
  ./ai-dev configure --show       # Show current config
  ./ai-dev configure --help       # Show this help

${GREEN}Note:${NC} Configuration changes affect all framework commands.
EOF
            exit 0
        fi
        
        info "Configuring framework settings"
        export CONFIGURE_OPTIONS="$*"
        execute_workflow "${AI_WORKFLOW_DIR}/workflows/cli/configure_framework.md" "Framework Configuration"
        ;;

    diagnose)
        info "Diagnosing framework health"
        execute_workflow "${AI_WORKFLOW_DIR}/workflows/cli/diagnose_framework.md" "Framework Diagnosis"
        ;;

    quality)
        PROJECT_PATH=${1:-"."}
        if [ ! -d "$PROJECT_PATH" ]; then
            error "Directory not found: $PROJECT_PATH"
            exit 1
        fi
        
        info "Running quality validation on: $PROJECT_PATH"
        export PROJECT_PATH
        execute_workflow "${AI_WORKFLOW_DIR}/workflows/quality/quality_gates.md" "Quality Validation"
        ;;

    status)
        # Check for status-specific flags after the command
        for arg in "$@"; do
            case $arg in
                -q|--quiet)
                    QUIET=true
                    ;;
                -v|--verbose)
                    VERBOSE=true
                    ;;
            esac
        done
        
        # Show CLI initialization message only if not in quiet mode
        if [ "$QUIET" != "true" ]; then
            info "AI Development Framework CLI v2.0"
            info "Framework Status Report"
            echo ""
            echo "Framework Directory: $AI_WORKFLOW_DIR"
            echo "Config File: $CONFIG_FILE"
            echo "Cache Directory: $CACHE_DIR"
            echo "Log File: $LOG_FILE"
            echo ""
        fi
        
        if [ -f "$CONFIG_FILE" ]; then
            echo "Configuration: ✅ Found"
        else
            echo "Configuration: ❌ Not found"
        fi
        
        if [ -d "${AI_WORKFLOW_DIR}/workflows" ]; then
            workflow_count=$(find "${AI_WORKFLOW_DIR}/workflows" -name "*.md" | wc -l)
            echo "Workflows: ✅ $workflow_count found"
        else
            echo "Workflows: ❌ Directory missing"
        fi
        
        if [ -w "$CACHE_DIR" ]; then
            echo "Cache Directory: ✅ Writable"
        else
            echo "Cache Directory: ❌ Not writable"
        fi
        ;;

    version)
        echo "AI Development Framework CLI v2.0"
        echo "Enhanced with robust validation, integration testing, and pre-commit system"
        echo "Framework Version: v0.4.1-beta"
        if [ -f "${AI_WORKFLOW_DIR}/VERSION" ]; then
            echo "Additional Version Info: $(cat "${AI_WORKFLOW_DIR}/VERSION")"
        fi
        ;;

    help|--help|-h)
        show_help
        ;;

    test-workflow-calling)
        info "Testing workflow calling mechanism"
        execute_workflow "${AI_WORKFLOW_DIR}/testing/test_workflow_calling.md" "Workflow Calling Test"
        ;;

    test-simple-audit)
        info "Testing simple audit workflow"
        execute_workflow "${AI_WORKFLOW_DIR}/testing/simple_audit_test.md" "Simple Audit Test"
        ;;

    precommit)
        # Handle precommit subcommands
        SUBCOMMAND=${1:-validate}
        shift || true
        
        case "$SUBCOMMAND" in
            validate)
                info "Running pre-commit validation"
                execute_workflow "${AI_WORKFLOW_DIR}/precommit/validators/precommit_validation.md" "Pre-commit Validation"
                ;;
            install-hooks)
                info "Installing git hooks"
                execute_workflow "${AI_WORKFLOW_DIR}/precommit/install_hooks.md" "Install Git Hooks"
                ;;
            configure)
                info "Configuring pre-commit system"
                execute_workflow "${AI_WORKFLOW_DIR}/precommit/configure_precommit.md" "Configure Pre-commit"
                ;;
            report)
                info "Generating pre-commit report"
                execute_workflow "${AI_WORKFLOW_DIR}/precommit/generate_report.md" "Generate Pre-commit Report"
                ;;
            --help|-h)
                cat << EOF
${BLUE}Pre-commit Command Help${NC}

${GREEN}Usage:${NC} ./ai-dev precommit <subcommand> [options]

${GREEN}Subcommands:${NC}
  validate           Run pre-commit validation on current changes
  install-hooks      Install git hooks for automatic validation
  configure          Configure pre-commit validation rules
  report             Generate quality and validation report

${GREEN}Examples:${NC}
  ./ai-dev precommit validate       # Validate current changes
  ./ai-dev precommit install-hooks  # Install git hooks
  ./ai-dev precommit configure      # Configure validation rules
  ./ai-dev precommit report         # Generate validation report
EOF
                exit 0
                ;;
            *)
                error "Unknown precommit subcommand: '$SUBCOMMAND'"
                echo ""
                info "Available subcommands: validate, install-hooks, configure, report"
                echo "Use './ai-dev precommit --help' for more information"
                exit 1
                ;;
        esac
        ;;

    *)
        error "Unknown command: '$COMMAND'"
        echo ""
        info "Available commands: setup, generate, run, optimize, audit, sync, configure, diagnose, quality, status, version, help, precommit, test-workflow-calling, test-simple-audit"
        show_help
        exit 1
        ;;
esac

# Log successful execution
log "Command completed successfully: $COMMAND"
exit 0
