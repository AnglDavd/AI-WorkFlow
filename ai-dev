#!/bin/bash

# ai-dev - Ultra-Simple AI Development Framework CLI
# Version: 3.1 - Enhanced with real-time collaboration
# Core Commands: create-prd, generate, execute
# Collaboration: collaborate, dev, context
# Real-time AI-developer integration without additional files

set -euo pipefail

# --- Global Variables ---
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# AI guide files are now in root directory

# Session ID generation for workflow traceability
generate_session_id() {
    echo "$(date +%s | tail -c 6)"
}

# Colors for output
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly PURPLE='\033[0;35m'
readonly CYAN='\033[0;36m'
readonly NC='\033[0m' # No Color
readonly BOLD='\033[1m'

# --- Utility Functions ---
log() {
    echo -e "${BLUE}[$(date '+%H:%M:%S')]${NC} $1"
}

success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

title() {
    echo -e "\n${BOLD}${PURPLE}$1${NC}\n"
}

# --- Collaboration Functions ---
get_session_state() {
    local session_id="$1"
    
    # Use comments in existing files for state tracking
    local tasks_file=$(ls "02_tasks_${session_id}_"*.md 2>/dev/null | head -1)
    if [ -f "$tasks_file" ]; then
        grep "<!-- STATE:" "$tasks_file" 2>/dev/null | tail -1 | sed 's/.*STATE: //' | sed 's/ -->.*//'
    else
        echo "session_not_found"
    fi
}

update_session_state() {
    local session_id="$1"
    local current_task="$2"
    local status="$3"
    
    # Add state as comment to tasks file
    local tasks_file=$(ls "02_tasks_${session_id}_"*.md 2>/dev/null | head -1)
    if [ -f "$tasks_file" ]; then
        echo "<!-- STATE: task=$current_task status=$status timestamp=$(date +%s) -->" >> "$tasks_file"
        log "Session state updated: $current_task -> $status"
    else
        error "Tasks file not found for session: $session_id"
        return 1
    fi
}

load_full_context() {
    local session_id="$1"
    
    log "Loading full context for session: $session_id"
    
    # Load PRD
    local prd_file=$(ls "01_prd_${session_id}_"*.md 2>/dev/null | head -1)
    if [ -f "$prd_file" ]; then
        local word_count=$(wc -w < "$prd_file")
        success "PRD loaded: $word_count words"
        export AI_CONTEXT_PRD="$prd_file"
    else
        error "PRD file not found for session: $session_id"
        return 1
    fi
    
    # Load tasks
    local tasks_file=$(ls "02_tasks_${session_id}_"*.md 2>/dev/null | head -1)
    if [ -f "$tasks_file" ]; then
        local total_tasks=$(grep -c "### Task" "$tasks_file" 2>/dev/null || echo 0)
        success "Tasks loaded: $total_tasks tasks"
        export AI_CONTEXT_TASKS="$tasks_file"
    else
        error "Tasks file not found for session: $session_id"
        return 1
    fi
    
    # Load current state
    local current_state=$(get_session_state "$session_id")
    success "Current state: $current_state"
    export AI_CONTEXT_SESSION="$session_id"
    
    return 0
}

validate_current_progress() {
    local session_id="$1"
    local quiet="${2:-false}"
    
    local tasks_file=$(ls "02_tasks_${session_id}_"*.md 2>/dev/null | head -1)
    if [ ! -f "$tasks_file" ]; then
        error "Tasks file not found for session: $session_id"
        return 1
    fi
    
    # Count completed tasks
    local completed_tasks=$(grep -c "✅" "$tasks_file" 2>/dev/null || echo 0)
    local total_tasks=$(grep -c "### Task" "$tasks_file" 2>/dev/null || echo 1)
    
    if [ "$quiet" != "true" ]; then
        title "📊 Progress Validation: Session $session_id"
        echo "Progress: $completed_tasks/$total_tasks tasks completed"
        
        # Show pending acceptance criteria
        echo ""
        echo "Pending Acceptance Criteria:"
        grep -A 5 "**Acceptance Criteria:**" "$tasks_file" | while read -r line; do
            if [[ "$line" =~ ^\-\ \[\ \] ]]; then
                echo "❌ ${line#- [ ] }"
            elif [[ "$line" =~ ^\-\ \[x\] ]]; then
                echo "✅ ${line#- [x] }"
            fi
        done
    fi
    
    # Return success if more than 80% complete
    local progress_percent=$((completed_tasks * 100 / total_tasks))
    [ $progress_percent -gt 80 ]
}

get_next_recommended_task() {
    local session_id="$1"
    local tasks_file=$(ls "02_tasks_${session_id}_"*.md 2>/dev/null | head -1)
    
    if [ ! -f "$tasks_file" ]; then
        error "Tasks file not found for session: $session_id"
        return 1
    fi
    
    # Find first uncompleted task
    local next_task=$(awk '/### Task/ { task=$0; getline; while(getline && !/### Task/ && !/✅/) { if(/❌/) { task=""; break } } if(task!="") { print task; exit } }' "$tasks_file")
    
    if [ -n "$next_task" ]; then
        echo "🎯 Next recommended task:"
        echo "   $next_task"
        
        # Show acceptance criteria for this task
        local task_line=$(grep -n "$next_task" "$tasks_file" | cut -d: -f1)
        if [ -n "$task_line" ]; then
            echo ""
            echo "Acceptance Criteria:"
            sed -n "${task_line},+20p" "$tasks_file" | grep -A 10 "**Acceptance Criteria:**" | while read -r line; do
                if [[ "$line" =~ ^\-\ \[\ \] ]]; then
                    echo "   $line"
                fi
            done
        fi
    else
        success "All tasks completed!"
    fi
}

validate_code_against_criteria() {
    local session_id="$1"
    local file_path="$2"
    local tasks_file=$(ls "02_tasks_${session_id}_"*.md 2>/dev/null | head -1)
    
    if [ ! -f "$file_path" ]; then
        error "File not found: $file_path"
        return 1
    fi
    
    if [ ! -f "$tasks_file" ]; then
        error "Tasks file not found for session: $session_id"
        return 1
    fi
    
    title "👁️ Code Review: $(basename "$file_path")"
    
    # Extract and validate against acceptance criteria
    grep -A 10 "**Acceptance Criteria:**" "$tasks_file" | while read -r line; do
        if [[ "$line" =~ ^\-\ \[\ \] ]]; then
            local check="${line#- [ ] }"
            
            case "$check" in
                *"error handling"*|*"exception"*)
                    if grep -q "try\|catch\|throw\|error\|Exception" "$file_path"; then
                        echo "✅ Error handling found"
                    else
                        echo "❌ No error handling detected"
                    fi
                    ;;
                *"input validation"*|*"sanitiz"*)
                    if grep -q "validate\|sanitize\|filter\|escape" "$file_path"; then
                        echo "✅ Input validation found"
                    else
                        echo "❌ No input validation detected"
                    fi
                    ;;
                *"documentation"*|*"comment"*)
                    if grep -q "\/\*\*\|\/\/\|#\|@param\|@return" "$file_path"; then
                        echo "✅ Documentation comments found"
                    else
                        echo "❌ No documentation detected"
                    fi
                    ;;
                *"test"*|*"unit test"*)
                    local test_file="${file_path%.*}.test.${file_path##*.}"
                    if [ -f "$test_file" ] || grep -q "test\|Test\|assert" "$file_path"; then
                        echo "✅ Tests found"
                    else
                        echo "❌ No tests detected"
                    fi
                    ;;
                *"security"*|*"SQL injection"*|*"XSS"*)
                    if grep -q "prepare\|bind\|escape\|sanitize\|nonce" "$file_path"; then
                        echo "✅ Security measures found"
                    else
                        echo "❌ No security measures detected"
                    fi
                    ;;
                *)
                    echo "ℹ️  Manual check needed: $check"
                    ;;
            esac
        fi
    done
}

start_continuous_validation() {
    local session_id="$1"
    
    title "🔄 Starting Continuous Validation"
    
    # Create monitoring script
    cat > "/tmp/validate_${session_id}.sh" << EOF
#!/bin/bash
while true; do
    sleep 30
    if "$0" dev --validate "$session_id" --quiet > /dev/null 2>&1; then
        echo "\$(date '+%H:%M:%S'): ✅ Validation passed"
    else
        echo "\$(date '+%H:%M:%S'): ❌ Validation failed - attention needed"
    fi
done
EOF
    
    chmod +x "/tmp/validate_${session_id}.sh"
    nohup "/tmp/validate_${session_id}.sh" > "/tmp/validation_${session_id}.log" 2>&1 &
    local pid=$!
    
    success "Continuous validation started (PID: $pid)"
    log "Monitor with: tail -f /tmp/validation_${session_id}.log"
    log "Stop with: kill $pid"
    
    echo "$pid" > "/tmp/validate_${session_id}.pid"
}

stop_continuous_validation() {
    local session_id="$1"
    
    if [ -f "/tmp/validate_${session_id}.pid" ]; then
        local pid=$(cat "/tmp/validate_${session_id}.pid")
        if kill "$pid" 2>/dev/null; then
            success "Continuous validation stopped (PID: $pid)"
            rm -f "/tmp/validate_${session_id}.pid"
            rm -f "/tmp/validate_${session_id}.sh"
        else
            warning "Validation process not found or already stopped"
        fi
    else
        warning "No continuous validation running for session: $session_id"
    fi
}

# --- Level 1 Enhancement Functions ---

save_session_context() {
    local session_id="$1"
    local context_file=".ai_context_${session_id}.json"
    
    log "Saving session context for: $session_id"
    
    # Gather all session information
    local prd_file=$(ls "01_prd_${session_id}_"*.md 2>/dev/null | head -1)
    local tasks_file=$(ls "02_tasks_${session_id}_"*.md 2>/dev/null | head -1)
    local report_file=$(ls "03_report_${session_id}_"*.md 2>/dev/null | head -1)
    
    # Create context JSON
    cat > "$context_file" << EOF
{
    "session_id": "$session_id",
    "created": "$(date -Iseconds)",
    "last_updated": "$(date -Iseconds)",
    "files": {
        "prd": "$(basename "$prd_file" 2>/dev/null || echo "")",
        "tasks": "$(basename "$tasks_file" 2>/dev/null || echo "")",
        "report": "$(basename "$report_file" 2>/dev/null || echo "")"
    },
    "project_metadata": {
        "name": "$(echo "$prd_file" | sed 's/.*_\(.*\)\.md/\1/' 2>/dev/null || echo "")",
        "complexity": "$(grep "Complexity Assessment:" "$prd_file" 2>/dev/null | cut -d: -f2 | xargs || echo "Unknown")",
        "tech_stack": "$(grep "TECH_APPROVED:" "$prd_file" 2>/dev/null | tail -1 | sed 's/.*TECH_APPROVED: \([^[:space:]]*\).*/\1/' || echo "None")"
    },
    "progress": {
        "total_tasks": $(grep -c "### Task" "$tasks_file" 2>/dev/null || echo 0),
        "completed_tasks": $(grep -c "✅" "$tasks_file" 2>/dev/null || echo 0),
        "approved_tasks": $(grep -c "APPROVED:" "$tasks_file" 2>/dev/null || echo 0),
        "proposed_tasks": $(grep -c "PROPOSED:" "$tasks_file" 2>/dev/null || echo 0)
    },
    "decisions": [],
    "risk_factors": [],
    "notes": []
}
EOF
    
    # Extract and save decision history
    if [ -f "$tasks_file" ]; then
        extract_decision_history "$session_id" "$tasks_file" "$context_file"
    fi
    
    success "Session context saved: $context_file"
}

extract_decision_history() {
    local session_id="$1"
    local tasks_file="$2"
    local context_file="$3"
    
    # Extract decisions from comments
    local decisions=""
    local temp_decisions="/tmp/decisions_${session_id}.json"
    
    echo '[]' > "$temp_decisions"
    
    # Extract TECH_APPROVED decisions
    if grep -q "TECH_APPROVED:" "$tasks_file"; then
        local tech_decision=$(grep "TECH_APPROVED:" "$tasks_file" | tail -1)
        local tech_option=$(echo "$tech_decision" | sed 's/.*TECH_APPROVED: \([^[:space:]]*\).*/\1/')
        
        jq ". += [{\"type\": \"technology\", \"decision\": \"$tech_option\", \"timestamp\": \"$(date -Iseconds)\", \"source\": \"tech_approval\"}]" "$temp_decisions" > "${temp_decisions}.tmp"
        mv "${temp_decisions}.tmp" "$temp_decisions"
    fi
    
    # Extract APPROVED task decisions
    grep "APPROVED:" "$tasks_file" 2>/dev/null | while read -r approval; do
        local task_id=$(echo "$approval" | sed 's/.*task=\([^[:space:]]*\).*/\1/')
        local timestamp=$(echo "$approval" | sed 's/.*timestamp=\([^[:space:]]*\).*/\1/')
        local changes=$(echo "$approval" | sed 's/.*changes="\([^"]*\)".*/\1/' 2>/dev/null || echo "")
        
        if [ -n "$changes" ]; then
            jq ". += [{\"type\": \"task_approval\", \"task_id\": \"$task_id\", \"changes\": \"$changes\", \"timestamp\": \"$timestamp\", \"source\": \"developer_approval\"}]" "$temp_decisions" > "${temp_decisions}.tmp"
        else
            jq ". += [{\"type\": \"task_approval\", \"task_id\": \"$task_id\", \"timestamp\": \"$timestamp\", \"source\": \"developer_approval\"}]" "$temp_decisions" > "${temp_decisions}.tmp"
        fi
        mv "${temp_decisions}.tmp" "$temp_decisions" 2>/dev/null || true
    done
    
    # Merge decisions into main context file
    if command -v jq >/dev/null 2>&1; then
        local temp_context="${context_file}.tmp"
        jq --slurpfile decisions "$temp_decisions" '.decisions = $decisions[0]' "$context_file" > "$temp_context"
        mv "$temp_context" "$context_file"
    fi
    
    rm -f "$temp_decisions" "${temp_decisions}.tmp"
}

restore_session_context() {
    local session_id="$1"
    local context_file=".ai_context_${session_id}.json"
    
    if [ ! -f "$context_file" ]; then
        warning "No saved context found for session: $session_id"
        return 1
    fi
    
    title "🧠 Restoring Session Context: $session_id"
    
    # Extract and display context information
    if command -v jq >/dev/null 2>&1; then
        local project_name=$(jq -r '.project_metadata.name' "$context_file" 2>/dev/null || echo "Unknown")
        local complexity=$(jq -r '.project_metadata.complexity' "$context_file" 2>/dev/null || echo "Unknown")
        local tech_stack=$(jq -r '.project_metadata.tech_stack' "$context_file" 2>/dev/null || echo "None")
        local total_tasks=$(jq -r '.progress.total_tasks' "$context_file" 2>/dev/null || echo "0")
        local completed_tasks=$(jq -r '.progress.completed_tasks' "$context_file" 2>/dev/null || echo "0")
        local approved_tasks=$(jq -r '.progress.approved_tasks' "$context_file" 2>/dev/null || echo "0")
        
        echo "📋 Project: $project_name"
        echo "🔧 Complexity: $complexity"
        echo "💻 Technology: $tech_stack"
        echo "📊 Progress: $completed_tasks/$total_tasks tasks completed"
        echo "✅ Approved: $approved_tasks tasks approved"
        echo ""
        
        # Show recent decisions
        echo "📝 Recent Decisions:"
        jq -r '.decisions[] | "  - \(.type): \(.decision // .task_id) (\(.timestamp[:19]))"' "$context_file" 2>/dev/null | tail -5 || echo "  No decisions recorded"
        
        success "Context restored successfully"
        
        # Set environment variables for AI context
        export AI_CONTEXT_SESSION="$session_id"
        export AI_CONTEXT_PROJECT="$project_name"
        export AI_CONTEXT_COMPLEXITY="$complexity"
        export AI_CONTEXT_TECH="$tech_stack"
        
    else
        warning "jq not available - limited context restoration"
        echo "Context file exists but cannot parse JSON without jq"
        return 1
    fi
}

compress_large_context() {
    local session_id="$1"
    local context_file=".ai_context_${session_id}.json"
    
    title "🗜️ Compressing Large Context: $session_id"
    
    # Check if files are too large for AI context
    local prd_file=$(ls "01_prd_${session_id}_"*.md 2>/dev/null | head -1)
    local tasks_file=$(ls "02_tasks_${session_id}_"*.md 2>/dev/null | head -1)
    
    if [ -f "$prd_file" ]; then
        local prd_size=$(wc -w < "$prd_file")
        if [ "$prd_size" -gt 4000 ]; then
            warning "PRD is large ($prd_size words) - creating summary"
            
            # Create compressed summary
            local summary_file="${prd_file%.md}_summary.md"
            create_prd_summary "$prd_file" "$summary_file"
            
            echo "📄 Created PRD summary: $summary_file"
        fi
    fi
    
    if [ -f "$tasks_file" ]; then
        local task_count=$(grep -c "### Task" "$tasks_file")
        if [ "$task_count" -gt 25 ]; then
            warning "Many tasks ($task_count) - creating focused view"
            
            # Create focused task view
            local focused_file="${tasks_file%.md}_current.md"
            create_focused_task_view "$tasks_file" "$focused_file" "$session_id"
            
            echo "📋 Created focused task view: $focused_file"
        fi
    fi
}

create_prd_summary() {
    local prd_file="$1"
    local summary_file="$2"
    
    cat > "$summary_file" << EOF
# PRD Summary (Auto-generated)

## Key Information
$(grep -A 5 "## 1. Project Overview" "$prd_file" | head -10)

## Technology Stack
$(grep -A 20 "## 2. Technology Stack Analysis" "$prd_file" | grep -E "(RECOMMENDED|Backend:|Frontend:|Database:)" | head -10)

## Critical Requirements
$(grep -E "^\*\*|^- \*\*" "$prd_file" | head -15)

## Budget & Timeline
$(grep -E "\$[0-9,]+|[0-9]+ weeks|[0-9]+ months" "$prd_file" | head -5)

---
*This is an auto-generated summary. See full PRD: $(basename "$prd_file")*
EOF
}

create_focused_task_view() {
    local tasks_file="$1"
    local focused_file="$2"
    local session_id="$3"
    
    cat > "$focused_file" << EOF
# Current Task Focus (Auto-generated)

## Active Tasks
EOF
    
    # Show next 3-5 uncompleted tasks
    local task_count=0
    grep -n "### Task" "$tasks_file" | while read -r line && [ $task_count -lt 5 ]; do
        local line_num=$(echo "$line" | cut -d: -f1)
        local task_title=$(echo "$line" | cut -d: -f2-)
        
        # Check if task is completed
        if ! sed -n "${line_num},+20p" "$tasks_file" | grep -q "✅"; then
            echo "" >> "$focused_file"
            sed -n "${line_num},+15p" "$tasks_file" | head -16 >> "$focused_file"
            task_count=$((task_count + 1))
        fi
    done
    
    echo "" >> "$focused_file"
    echo "---" >> "$focused_file"
    echo "*Showing next 5 uncompleted tasks. See full plan: $(basename "$tasks_file")*" >> "$focused_file"
}

validate_dependencies() {
    local session_id="$1"
    local task_id="${2:-all}"
    
    title "🔍 Dependency Validation: Session $session_id"
    
    local tasks_file=$(ls "02_tasks_${session_id}_"*.md 2>/dev/null | head -1)
    local prd_file=$(ls "01_prd_${session_id}_"*.md 2>/dev/null | head -1)
    
    if [ ! -f "$tasks_file" ] || [ ! -f "$prd_file" ]; then
        error "Required files not found for dependency validation"
        return 1
    fi
    
    local issues=0
    
    # Check technology consistency
    local prd_tech=$(grep "TECH_APPROVED:" "$prd_file" 2>/dev/null | tail -1 | sed 's/.*TECH_APPROVED: \([^[:space:]]*\).*/\1/' || echo "")
    local tasks_tech=""
    
    if grep -q "PHP\|Laravel\|MySQL" "$tasks_file"; then
        tasks_tech="php-stack"
    elif grep -q "Python\|Django\|FastAPI" "$tasks_file"; then
        tasks_tech="python-stack"
    elif grep -q "Node\|Express\|JavaScript" "$tasks_file"; then
        tasks_tech="node-stack"
    fi
    
    if [ -n "$prd_tech" ] && [ -n "$tasks_tech" ]; then
        if [[ "$prd_tech" != *"$tasks_tech"* ]] && [[ "$tasks_tech" != *"$prd_tech"* ]]; then
            warning "Technology mismatch: PRD approved '$prd_tech' but tasks use '$tasks_tech'"
            issues=$((issues + 1))
        else
            success "Technology stack consistent between PRD and tasks"
        fi
    fi
    
    # Check task dependencies
    echo ""
    echo "📋 Task Dependency Analysis:"
    
    local database_task=$(grep -n "database\|schema\|model" "$tasks_file" | head -1 | cut -d: -f1)
    local auth_task=$(grep -n "authentication\|login\|user" "$tasks_file" | head -1 | cut -d: -f1)
    local frontend_task=$(grep -n "frontend\|UI\|interface" "$tasks_file" | head -1 | cut -d: -f1)
    
    if [ -n "$database_task" ] && [ -n "$auth_task" ]; then
        if [ "$database_task" -gt "$auth_task" ]; then
            warning "Dependency issue: Authentication task before database setup"
            echo "  Recommendation: Complete database tasks before authentication"
            issues=$((issues + 1))
        else
            success "Database setup scheduled before authentication"
        fi
    fi
    
    if [ -n "$auth_task" ] && [ -n "$frontend_task" ]; then
        if [ "$auth_task" -gt "$frontend_task" ]; then
            warning "Dependency issue: Frontend tasks before authentication"
            echo "  Recommendation: Complete authentication before frontend integration"
            issues=$((issues + 1))
        else
            success "Authentication scheduled before frontend integration"
        fi
    fi
    
    # Check for missing critical tasks
    echo ""
    echo "🔍 Critical Task Coverage:"
    
    local has_security=$(grep -c "security\|validation\|sanitiz" "$tasks_file")
    local has_testing=$(grep -c "test\|testing\|QA" "$tasks_file")
    local has_deployment=$(grep -c "deploy\|production\|hosting" "$tasks_file")
    
    if [ "$has_security" -eq 0 ]; then
        warning "Missing security tasks - add input validation and security measures"
        issues=$((issues + 1))
    else
        success "Security tasks included ($has_security found)"
    fi
    
    if [ "$has_testing" -eq 0 ]; then
        warning "Missing testing tasks - add quality assurance tasks"
        issues=$((issues + 1))
    else
        success "Testing tasks included ($has_testing found)"
    fi
    
    if [ "$has_deployment" -eq 0 ]; then
        warning "Missing deployment tasks - add production deployment plan"
        issues=$((issues + 1))
    else
        success "Deployment tasks included ($has_deployment found)"
    fi
    
    echo ""
    if [ "$issues" -eq 0 ]; then
        success "✅ All dependency validations passed"
        return 0
    else
        warning "⚠️ Found $issues dependency issues that should be addressed"
        return 1
    fi
}

enhanced_error_handler() {
    local error_type="$1"
    local session_id="$2"
    local context="$3"
    local suggestion="$4"
    
    title "🚨 Enhanced Error Handler: $error_type"
    
    echo "📍 Context: $context"
    echo "🔧 Session: $session_id"
    echo ""
    
    case "$error_type" in
        "missing_file")
            echo "❌ File not found error detected"
            echo "🔍 Checking for alternative files..."
            
            # Try to find similar files
            if [[ "$context" == *"prd"* ]]; then
                echo "Looking for PRD files:"
                ls 01_prd_*.md 2>/dev/null | head -3 || echo "  No PRD files found"
            elif [[ "$context" == *"tasks"* ]]; then
                echo "Looking for task files:"
                ls 02_tasks_*.md 2>/dev/null | head -3 || echo "  No task files found"
            fi
            
            echo ""
            echo "💡 Suggestions:"
            echo "  1. Check session ID format (6 digits)"
            echo "  2. Verify files were created successfully"
            echo "  3. Use './ai-dev status' to see available sessions"
            ;;
            
        "context_overload")
            echo "❌ Context size exceeding optimal limits"
            echo "🔍 Analyzing context size..."
            
            if [ -n "$session_id" ]; then
                compress_large_context "$session_id"
            fi
            
            echo ""
            echo "💡 Suggestions:"
            echo "  1. Use compressed context files created above"
            echo "  2. Focus on current phase tasks only"
            echo "  3. Save context and restart session if needed"
            ;;
            
        "dependency_conflict")
            echo "❌ Dependency conflict detected"
            echo "🔍 Running dependency validation..."
            
            if [ -n "$session_id" ]; then
                validate_dependencies "$session_id"
            fi
            
            echo ""
            echo "💡 Suggestions:"
            echo "  1. Review dependency validation results above"
            echo "  2. Adjust task order if needed"
            echo "  3. Update technology stack if inconsistent"
            ;;
            
        "approval_required")
            echo "❌ Operation requires approval but none found"
            echo "🔍 Checking approval status..."
            
            if [ -n "$session_id" ]; then
                local tasks_file=$(ls "02_tasks_${session_id}_"*.md 2>/dev/null | head -1)
                if [ -f "$tasks_file" ]; then
                    local proposed=$(grep -c "PROPOSED:" "$tasks_file" 2>/dev/null || echo 0)
                    local approved=$(grep -c "APPROVED:" "$tasks_file" 2>/dev/null || echo 0)
                    echo "  Proposed tasks: $proposed"
                    echo "  Approved tasks: $approved"
                fi
            fi
            
            echo ""
            echo "💡 Suggestions:"
            echo "  1. Use './ai-dev dev --propose $session_id task-id' first"
            echo "  2. Review with './ai-dev collaborate --preview $session_id task-id'"
            echo "  3. Approve with './ai-dev dev --approve $session_id task-id'"
            ;;
            
        *)
            echo "❌ Unknown error type: $error_type"
            echo "📝 Context: $context"
            
            if [ -n "$suggestion" ]; then
                echo ""
                echo "💡 Suggestion: $suggestion"
            fi
            ;;
    esac
    
    echo ""
    echo "🆘 If issues persist:"
    echo "  - Check './ai-dev status' for system health"
    echo "  - Use './ai-dev context --save $session_id' to preserve work"
    echo "  - Review session files manually"
}

# --- Help Function ---
show_help() {
    cat << EOF
${BLUE}AI Development Framework CLI v3.1${NC}
${CYAN}Enhanced with Real-Time AI-Developer Collaboration${NC}

${GREEN}Usage:${NC} ./ai-dev <command> [arguments]

${GREEN}Core Commands:${NC}
  ${BOLD}create-prd${NC}              Create ultra-detailed Product Requirements Document
  ${BOLD}generate <prd_file>${NC}     Generate implementation tasks from PRD
  ${BOLD}execute <tasks_file>${NC}    Execute tasks with automatic GitHub backup

${GREEN}Collaboration Commands:${NC}
  ${BOLD}collaborate --start <session_id>${NC}      Start real-time collaborative session
  ${BOLD}collaborate --sync <session_id>${NC}       Synchronize progress and get next task
  ${BOLD}collaborate --review <session_id> <file>${NC}  Review code against acceptance criteria
  ${BOLD}collaborate --monitor <session_id>${NC}    Start continuous validation monitoring
  ${BOLD}collaborate --review-tech <session_id>${NC}     Review and approve technology stack
  ${BOLD}collaborate --preview <session_id> <task_id>${NC}  Preview AI implementation approach

${GREEN}Development Commands:${NC}
  ${BOLD}dev --validate <session_id>${NC}           Validate current progress against plan
  ${BOLD}dev --next <session_id>${NC}               Show next recommended task
  ${BOLD}dev --status <session_id>${NC}             Show detailed session status
  ${BOLD}dev --propose <session_id> <task_id>${NC}       AI proposes task implementation
  ${BOLD}dev --approve <session_id> <task_id>${NC}       Developer approves AI proposal

${GREEN}Context Commands:${NC}
  ${BOLD}context --load <session_id>${NC}           Load full session context for AI
  ${BOLD}context --save <session_id>${NC}           Save session context persistently
  ${BOLD}context --restore <session_id>${NC}        Restore saved session context
  ${BOLD}context --compress <session_id>${NC}       Compress large context files
  ${BOLD}context --validate-deps <session_id>${NC}  Validate project dependencies
  ${BOLD}context --update <session_id> <task> <status>${NC}  Update task status
  ${BOLD}context --analyze <session_id>${NC}        Analyze progress vs original plan

${GREEN}UI/UX Healing Commands:${NC}
  ${BOLD}heal analyze <url>${NC}                    Comprehensive UI/UX healing analysis
  ${BOLD}heal report <session_id>${NC}              View healing analysis report
  ${BOLD}heal fix <session_id>${NC}                 Apply healing fixes (manual review)
  ${BOLD}heal validate${NC}                         Check MCP Playwright prerequisites

${GREEN}Iterative Quality Commands:${NC}
  ${BOLD}iterate start <session_id> <url>${NC}      Start iterative quality improvement loop
  ${BOLD}iterate status <session_id>${NC}           Show current iteration status
  ${BOLD}iterate report <session_id>${NC}           Display quality report or manual plan
  ${BOLD}iterate retry <session_id> <url>${NC}      Clean up and retry quality loop

${GREEN}Specialized Analysis Commands:${NC}
  ${BOLD}analyze ui <url>${NC}                      Visual consistency analysis
  ${BOLD}analyze performance <url>${NC}             Performance optimization analysis
  ${BOLD}analyze accessibility <url>${NC}           WCAG 2.1 compliance testing
  ${BOLD}analyze cro <url>${NC}                     Conversion rate optimization analysis

${GREEN}Process Flow:${NC}
  ${CYAN}1.${NC} ./ai-dev create-prd                    → Creates detailed PRD with tech options
  ${CYAN}2.${NC} ./ai-dev collaborate --review-tech xxx → Review and approve technology stack
  ${CYAN}3.${NC} ./ai-dev generate 01_prd_xxx.md → Generates task breakdown
  ${CYAN}4.${NC} ./ai-dev collaborate --start xxx  → Start AI collaboration with supervision
  ${CYAN}5.${NC} ./ai-dev execute 02_tasks_xxx.md → Implements + backs up to GitHub

${GREEN}Supervision Workflow:${NC}
  ${CYAN}→${NC} ./ai-dev dev --propose xxx task-2-1     → AI proposes implementation approach
  ${CYAN}→${NC} ./ai-dev collaborate --preview xxx task-2-1  → Review detailed implementation plan
  ${CYAN}→${NC} ./ai-dev dev --approve xxx task-2-1     → Approve or request changes
  ${CYAN}→${NC} ./ai-dev dev --status xxx               → Monitor implementation progress

${GREEN}What Each Step Does:${NC}

  ${BOLD}create-prd:${NC}
  - Interactive comprehensive interview process
  - Extracts maximum project detail and context
  - Creates 3000+ word PRD with business & technical requirements
  - Saves to 01_prd_{session-id}_{project}.md

  ${BOLD}generate:${NC}
  - Analyzes PRD and breaks down into 5 implementation phases
  - Creates detailed tasks with acceptance criteria
  - Includes architecture, development, testing, and deployment
  - Saves to 02_tasks_{session-id}_{project}.md

  ${BOLD}execute:${NC}
  - Executes each task phase-by-phase with production-ready code
  - Continuous GitHub backup at each milestone
  - Comprehensive testing and quality validation
  - Creates complete project with documentation

${GREEN}Examples:${NC}
  ./ai-dev create-prd
  ./ai-dev generate 01_prd_abc123_my-app.md
  ./ai-dev execute 02_tasks_abc123_my-app.md

${GREEN}Features:${NC}
  ✅ Ultra-detailed requirements gathering
  ✅ Comprehensive task breakdown with 5 phases
  ✅ Production-ready code implementation
  ✅ Automatic GitHub backup and versioning
  ✅ Quality gates and testing integration
  ✅ Complete documentation generation
  🆕 Real-time AI-developer collaboration
  🆕 Technology stack analysis and approval workflow
  🆕 AI supervision with proposal-approval system
  🆕 Implementation preview before execution
  🆕 Continuous validation monitoring
  🆕 Code review against acceptance criteria
  🆕 Progress tracking and context management
  ⭐ **NEW LEVEL 1**: Persistent context system
  ⭐ **NEW LEVEL 1**: Enhanced error handling with smart recovery
  ⭐ **NEW LEVEL 1**: Dependency validation and conflict detection
  ⭐ **NEW LEVEL 1**: Large project context compression
  🔥 **NEW HEALING**: Automated UI/UX analysis with MCP Playwright
  🔥 **NEW HEALING**: Comprehensive scoring system (1-10, min 8)
  🔥 **NEW HEALING**: 88 proven CRO patterns integration
  🔥 **NEW HEALING**: Accessibility, performance, and responsive testing

${GREEN}Directory Structure Created:${NC}
  01_prd_*       - Product Requirements Documents (Step 1)
  02_tasks_*     - Implementation task breakdowns (Step 2)
  03_report_*    - Execution and quality reports (Step 3)

For detailed help on any command: ./ai-dev <command> --help
EOF
}

# --- Validation Functions ---
validate_environment() {
    local issues=0
    
    # Check if we have the required guide files
    local required_files=(
        "create_prd_guide.md"
        "generate_tasks_guide.md" 
        "execute_tasks_guide.md"
    )
    
    log "Validating framework environment..."
    
    for file in "${required_files[@]}"; do
        if [ ! -f "$file" ]; then
            error "Required guide file missing: $file"
            issues=$((issues + 1))
        fi
    done
    
    # Check script permissions
    if [ ! -x "$0" ]; then
        warning "ai-dev script not executable - fixing permissions"
        chmod +x "$0" 2>/dev/null || {
            error "Cannot fix permissions. Run: chmod +x ai-dev"
            issues=$((issues + 1))
        }
    fi
    
    # Check for common required tools
    local tools=("sed" "grep" "awk" "date" "wc")
    for tool in "${tools[@]}"; do
        if ! command -v "$tool" >/dev/null 2>&1; then
            error "Required tool missing: $tool"
            issues=$((issues + 1))
        fi
    done
    
    # Check write permissions in current directory
    if ! touch .framework_test 2>/dev/null; then
        error "No write permissions in current directory"
        issues=$((issues + 1))
    else
        rm -f .framework_test
    fi
    
    # Check for git (optional but recommended)
    if ! command -v git >/dev/null 2>&1; then
        warning "Git not found - GitHub backup features disabled"
    fi
    
    if [ $issues -gt 0 ]; then
        error "Environment validation failed with $issues issues"
        error "Framework may not function correctly"
        exit 1
    fi
    
    log "Environment validation passed"
}

validate_file_path() {
    local file_path="$1"
    local file_type="${2:-file}"
    
    # Security: Prevent path traversal attacks
    if [[ "$file_path" == *".."* ]]; then
        error "Invalid file path: Path traversal not allowed"
        return 1
    fi
    
    # Check if file exists
    if [ ! -f "$file_path" ]; then
        # Use enhanced error handler
        local session_id=$(echo "$file_path" | sed 's/.*_\([0-9]\{6\}\)_.*/\1/' 2>/dev/null || echo "unknown")
        enhanced_error_handler "missing_file" "$session_id" "File not found: $file_path" "Check available files with ./ai-dev status"
        return 1
    fi
    
    # Check file extension for specific types
    case "$file_type" in
        "prd")
            if [[ "$file_path" != *.md ]]; then
                error "PRD file must be a markdown file (.md)"
                return 1
            fi
            ;;
        "tasks")
            if [[ "$file_path" != *.md ]]; then
                error "Tasks file must be a markdown file (.md)"
                return 1
            fi
            ;;
    esac
    
    # Check file readability
    if [ ! -r "$file_path" ]; then
        error "Cannot read file: $file_path"
        return 1
    fi
    
    log "File validation passed: $file_path"
    return 0
}

# --- AI Guide Execution Function ---
execute_ai_guide() {
    local guide_file="$1"
    local description="$2"
    shift 2
    local args="$*"
    
    title "🤖 $description"
    
    if [ ! -f "$guide_file" ]; then
        error "Guide file not found: $guide_file"
        exit 1
    fi
    
    log "Loading AI guide: $(basename "$guide_file")"
    log "Arguments: $args"
    
    # Read the guide content and provide it as context for AI execution
    echo -e "${CYAN}AI Guide Content:${NC}"
    echo "=================="
    cat "$guide_file"
    echo "=================="
    echo ""
    
    # For now, we'll execute any bash sections in the guide
    # In a real implementation, this would integrate with Claude Code or another AI
    local temp_script="/tmp/ai_guide_$$.sh"
    local in_bash_block=false
    local bash_content=""
    
    # Extract bash code blocks from the guide
    while IFS= read -r line; do
        # Detect start of bash code block
        if [[ "$line" =~ ^\`\`\`bash$ ]]; then
            in_bash_block=true
            bash_content=""
            continue
        fi
        
        # Detect end of code block
        if [[ "$line" =~ ^\`\`\`$ ]] && [ "$in_bash_block" = true ]; then
            in_bash_block=false
            
            if [ -n "$bash_content" ]; then
                # Create and execute bash script with proper variable assignment
                echo "#!/bin/bash" > "$temp_script"
                echo "set -euo pipefail" >> "$temp_script"
                echo "# Arguments: $args" >> "$temp_script"
                echo "" >> "$temp_script"
                
                # Export variables to script context
                if [ -n "$args" ]; then
                    local arg_array=($args)
                    echo "# Assign arguments to variables" >> "$temp_script"
                    echo "INPUT_FILE=\"${arg_array[0]:-}\"" >> "$temp_script"
                    echo "PRD_FILE=\"${arg_array[0]:-}\"" >> "$temp_script"
                    echo "TASKS_FILE=\"${arg_array[0]:-}\"" >> "$temp_script"
                    echo "" >> "$temp_script"
                fi
                
                echo "$bash_content" >> "$temp_script"
                chmod +x "$temp_script"
                
                log "Executing bash block from guide..."
                if bash "$temp_script"; then
                    success "Bash block executed successfully"
                else
                    error "Bash block execution failed"
                    rm -f "$temp_script"
                    exit 1
                fi
                
                rm -f "$temp_script"
            fi
            continue
        fi
        
        # Collect bash code lines
        if [ "$in_bash_block" = true ]; then
            bash_content="${bash_content}${line}
"
        fi
        
    done < "$guide_file"
    
    success "$description completed"
}

# --- Main Logic ---
COMMAND=${1:-}

# Show help if no command is provided
if [ -z "$COMMAND" ]; then
    show_help
    exit 0
fi

# Validate environment first
validate_environment

# Command routing
case "$COMMAND" in
    create-prd)
        if [[ "${2:-}" == "--help" ]] || [[ "${2:-}" == "-h" ]]; then
            cat << EOF
${BLUE}Create PRD Command Help${NC}

${GREEN}Usage:${NC} ./ai-dev create-prd

${GREEN}Description:${NC}
Interactive PRD creation process that extracts maximum detail about your project
through a comprehensive interview. Creates ultra-detailed Product Requirements
Documents with 3000+ words covering all technical and business aspects.

${GREEN}What it does:${NC}
- Comprehensive 5-section interview process
- Business vision and problem statement extraction  
- Technical architecture and requirements gathering
- Functional requirements and user story creation
- Implementation details and project planning
- Creates detailed PRD with sequential naming and session ID

${GREEN}Interview Sections:${NC}
1. Project Overview & Vision
2. Technical Requirements & Architecture  
3. Functional Requirements & User Stories
4. Implementation Details & Context
5. Project Planning & Timeline

${GREEN}Output:${NC}
- Ultra-detailed PRD file: 01_prd_{session-id}_{project}.md
- 3000+ words with comprehensive coverage
- Ready for task generation

${GREEN}Example:${NC}
  ./ai-dev create-prd

${GREEN}Next Step:${NC}
  ./ai-dev generate 01_prd_{session-id}_{your-project}.md
EOF
            exit 0
        fi
        
        execute_ai_guide "create_prd_guide.md" "Creating Ultra-Detailed PRD"
        ;;

    generate)
        if [[ "${2:-}" == "--help" ]] || [[ "${2:-}" == "-h" ]]; then
            cat << EOF
${BLUE}Generate Tasks Command Help${NC}

${GREEN}Usage:${NC} ./ai-dev generate <prd_file>

${GREEN}Description:${NC}
Converts a PRD into a comprehensive, phase-based implementation plan with detailed
tasks that any developer can execute step-by-step. Creates 5-phase breakdown with
specific acceptance criteria and validation commands.

${GREEN}Arguments:${NC}
  prd_file        Path to PRD markdown file (required)

${GREEN}What it does:${NC}
- Analyzes PRD content and extracts technical requirements
- Creates 5-phase implementation plan:
  1. Foundation & Setup
  2. Core Feature Development  
  3. Quality Assurance & Testing
  4. Deployment & Production
  5. Monitoring & Maintenance
- Detailed tasks with acceptance criteria
- Technology-specific customizations
- GitHub Actions workflow generation

${GREEN}Output:${NC}
- Comprehensive task file: 02_tasks_{session-id}_{project}.md
- 5 phases with detailed implementation steps
- Ready for execution

${GREEN}Examples:${NC}
  ./ai-dev generate 01_prd_abc123_my-app.md
  ./ai-dev generate 01_prd_def456_ecommerce-site.md

${GREEN}Next Step:${NC}
  ./ai-dev execute 02_tasks_{session-id}_{your-project}.md
EOF
            exit 0
        fi
        
        PRD_FILE=${2:-}
        if [ -z "$PRD_FILE" ]; then
            error "Missing required argument: <prd_file>"
            echo ""
            echo "Usage: ./ai-dev generate <prd_file>"
            echo "Example: ./ai-dev generate 01_prd_abc123_my-project.md"
            exit 1
        fi
        
        validate_file_path "$PRD_FILE" "prd"
        
        execute_ai_guide "generate_tasks_guide.md" "Generating Implementation Tasks" "$PRD_FILE"
        ;;

    execute)
        if [[ "${2:-}" == "--help" ]] || [[ "${2:-}" == "-h" ]]; then
            cat << EOF
${BLUE}Execute Tasks Command Help${NC}

${GREEN}Usage:${NC} ./ai-dev execute <tasks_file>

${GREEN}Description:${NC}
Executes the implementation plan step-by-step, writing production-ready code,
setting up infrastructure, and ensuring everything works perfectly while
maintaining GitHub backup throughout the process.

${GREEN}Arguments:${NC}
  tasks_file      Path to tasks markdown file (required)

${GREEN}What it does:${NC}
- Executes 5-phase implementation plan systematically
- Writes actual production-ready code with comprehensive error handling
- Sets up development environment and project architecture
- Implements features with testing and quality validation
- Configures deployment pipeline and monitoring
- Continuous GitHub backup at each milestone
- Creates comprehensive project documentation

${GREEN}Execution Process:${NC}
1. Environment preparation and GitHub setup
2. Phase-by-phase execution with milestone backups
3. Code quality validation and testing
4. Production deployment configuration
5. Final release creation and handover

${GREEN}Output:${NC}
- Fully implemented project with production-ready code
- Complete Git history with milestone commits
- Comprehensive documentation and tests
- Deployment-ready infrastructure

${GREEN}Examples:${NC}
  ./ai-dev execute 02_tasks_abc123_my-app.md
  ./ai-dev execute 02_tasks_def456_ecommerce-site.md

${GREEN}GitHub Integration:${NC}
- Automatic milestone commits with detailed messages
- Progressive backup strategy throughout development
- Final release tagging and documentation
- Complete project handover package
EOF
            exit 0
        fi
        
        TASKS_FILE=${2:-}
        if [ -z "$TASKS_FILE" ]; then
            error "Missing required argument: <tasks_file>"
            echo ""
            echo "Usage: ./ai-dev execute <tasks_file>"
            echo "Example: ./ai-dev execute 02_tasks_abc123_my-project.md"
            exit 1
        fi
        
        validate_file_path "$TASKS_FILE" "tasks"
        
        title "🛠️ Executing Implementation Plan with Mandatory Auto-Healing"
        execute_ai_guide "execute_tasks_guide.md" "Executing Implementation Plan" "$TASKS_FILE"
        ;;

    collaborate)
        SUBCOMMAND=${2:-}
        SESSION_ID=${3:-}
        
        case "$SUBCOMMAND" in
            --start)
                if [ -z "$SESSION_ID" ]; then
                    error "Missing session ID"
                    echo "Usage: ./ai-dev collaborate --start <session_id>"
                    exit 1
                fi
                
                title "🤝 Starting Collaborative Session: $SESSION_ID"
                
                if load_full_context "$SESSION_ID"; then
                    start_continuous_validation "$SESSION_ID"
                    get_next_recommended_task "$SESSION_ID"
                else
                    error "Failed to load session context"
                    exit 1
                fi
                ;;
                
            --sync)
                if [ -z "$SESSION_ID" ]; then
                    error "Missing session ID"
                    echo "Usage: ./ai-dev collaborate --sync <session_id>"
                    exit 1
                fi
                
                title "🔄 Synchronizing Progress: $SESSION_ID"
                
                validate_current_progress "$SESSION_ID"
                echo ""
                get_next_recommended_task "$SESSION_ID"
                ;;
                
            --review)
                FILE_PATH=${4:-}
                if [ -z "$SESSION_ID" ] || [ -z "$FILE_PATH" ]; then
                    error "Missing required arguments"
                    echo "Usage: ./ai-dev collaborate --review <session_id> <file_path>"
                    exit 1
                fi
                
                validate_code_against_criteria "$SESSION_ID" "$FILE_PATH"
                ;;
                
            --monitor)
                if [ -z "$SESSION_ID" ]; then
                    error "Missing session ID"
                    echo "Usage: ./ai-dev collaborate --monitor <session_id>"
                    exit 1
                fi
                
                start_continuous_validation "$SESSION_ID"
                ;;
                
            --stop)
                if [ -z "$SESSION_ID" ]; then
                    error "Missing session ID"
                    echo "Usage: ./ai-dev collaborate --stop <session_id>"
                    exit 1
                fi
                
                stop_continuous_validation "$SESSION_ID"
                ;;
                
            --review-tech)
                if [ -z "$SESSION_ID" ]; then
                    error "Missing session ID"
                    echo "Usage: ./ai-dev collaborate --review-tech <session_id>"
                    exit 1
                fi
                
                title "🤖 Technology Stack Review: Session $SESSION_ID"
                
                prd_file=$(ls "01_prd_${SESSION_ID}_"*.md 2>/dev/null | head -1)
                if [ -f "$prd_file" ]; then
                    # Show technology options from PRD
                    echo "Technology options from PRD analysis:"
                    echo "======================================"
                    
                    if grep -q "## 2. Technology Stack Analysis" "$prd_file"; then
                        # Extract technology section
                        sed -n '/## 2. Technology Stack Analysis/,/## 3./p' "$prd_file" | head -n -1
                        
                        echo ""
                        echo "📋 To approve a technology stack:"
                        echo "   1. Choose your preferred option (1 or 2)"
                        echo "   2. Add approval comment to PRD:"
                        echo "      echo '<!-- TECH_APPROVED: option-1 -->' >> $prd_file"
                        echo "   3. Generate tasks with chosen stack:"
                        echo "      ./ai-dev generate $prd_file"
                        echo ""
                        
                        # Check if already approved
                        if grep -q "<!-- TECH_APPROVED:" "$prd_file"; then
                            approved_option=$(grep "<!-- TECH_APPROVED:" "$prd_file" | tail -1 | sed 's/.*TECH_APPROVED: \([^[:space:]]*\).*/\1/')
                            success "Technology stack already approved: $approved_option"
                        else
                            warning "Technology stack not yet approved"
                            echo "Run: echo '<!-- TECH_APPROVED: option-1 -->' >> $prd_file"
                        fi
                    else
                        warning "No technology analysis found in PRD"
                        echo "This PRD was created before technology analysis was implemented"
                        echo "Consider regenerating the PRD to get technology options"
                    fi
                else
                    error "PRD file not found for session: $SESSION_ID"
                    exit 1
                fi
                ;;
                
            --preview)
                TASK_ID=${4:-}
                if [ -z "$SESSION_ID" ] || [ -z "$TASK_ID" ]; then
                    error "Missing required arguments"
                    echo "Usage: ./ai-dev collaborate --preview <session_id> <task_id>"
                    exit 1
                fi
                
                title "👁️ Implementation Preview: Task $TASK_ID"
                
                tasks_file=$(ls "02_tasks_${SESSION_ID}_"*.md 2>/dev/null | head -1)
                if [ -f "$tasks_file" ]; then
                    # Find the specific task
                    task_line=$(grep -n "### Task $TASK_ID" "$tasks_file" | cut -d: -f1)
                    
                    if [ -n "$task_line" ]; then
                        echo "🎯 Task Details:"
                        echo "==============="
                        
                        # Extract task section (from task title to next task or end)
                        sed -n "${task_line},/### Task [0-9]/p" "$tasks_file" | head -n -1 | sed '$d' || sed -n "${task_line},\$p" "$tasks_file"
                        
                        echo ""
                        echo "🤖 AI Implementation Approach:"
                        echo "==============================="
                        
                        # Generate implementation preview based on task content
                        task_content=$(sed -n "${task_line},/### Task [0-9]/p" "$tasks_file" | head -n -1 || sed -n "${task_line},\$p" "$tasks_file")
                        
                        # Analyze task content and suggest implementation
                        if echo "$task_content" | grep -qi "authentication\|login\|user"; then
                            echo "📁 Files to create/modify:"
                            echo "   - login.php (user authentication form)"
                            echo "   - session.php (session management functions)"
                            echo "   - auth_middleware.php (authentication validation)"
                            echo ""
                            echo "🔧 Key implementation points:"
                            echo "   - Password hashing with PHP password_hash()"
                            echo "   - CSRF token validation"
                            echo "   - Session security (httpOnly, secure flags)"
                            echo "   - Input sanitization and validation"
                        elif echo "$task_content" | grep -qi "database\|model\|schema"; then
                            echo "📁 Files to create/modify:"
                            echo "   - database/schema.sql (database structure)"
                            echo "   - models/ (data access layer)"
                            echo "   - config/database.php (connection settings)"
                            echo ""
                            echo "🔧 Key implementation points:"
                            echo "   - Prepared statements for SQL injection prevention"
                            echo "   - Connection pooling and error handling"
                            echo "   - Data validation and sanitization"
                        elif echo "$task_content" | grep -qi "frontend\|ui\|interface"; then
                            echo "📁 Files to create/modify:"
                            echo "   - assets/css/styles.css (responsive design)"
                            echo "   - assets/js/main.js (interactive functionality)"
                            echo "   - templates/ (HTML templates)"
                            echo ""
                            echo "🔧 Key implementation points:"
                            echo "   - Mobile-first responsive design"
                            echo "   - Accessibility (WCAG compliance)"
                            echo "   - Form validation and user feedback"
                        else
                            echo "📁 Files to be determined based on specific requirements"
                            echo "🔧 Implementation approach will follow task acceptance criteria"
                        fi
                        
                        echo ""
                        echo "📝 To approve this implementation approach:"
                        echo "   ./ai-dev dev --approve $SESSION_ID $TASK_ID"
                        echo ""
                        echo "📝 To approve with modifications:"
                        echo "   ./ai-dev dev --approve $SESSION_ID $TASK_ID --changes \"your feedback\""
                        
                        # Check if already proposed/approved
                        if grep -q "<!-- PROPOSED: task=$TASK_ID" "$tasks_file"; then
                            warning "Task already proposed by AI"
                        fi
                        
                        if grep -q "<!-- APPROVED: task=$TASK_ID" "$tasks_file"; then
                            approval=$(grep "<!-- APPROVED: task=$TASK_ID" "$tasks_file" | tail -1)
                            success "Task already approved: $approval"
                        fi
                    else
                        error "Task $TASK_ID not found in tasks file"
                        echo "Available tasks:"
                        grep "### Task" "$tasks_file" | head -5
                        exit 1
                    fi
                else
                    error "Tasks file not found for session: $SESSION_ID"
                    exit 1
                fi
                ;;
                
            *)
                error "Unknown collaborate subcommand: $SUBCOMMAND"
                echo "Available subcommands: --start, --sync, --review, --monitor, --stop, --review-tech, --preview"
                exit 1
                ;;
        esac
        ;;

    dev)
        SUBCOMMAND=${2:-}
        SESSION_ID=${3:-}
        
        case "$SUBCOMMAND" in
            --validate)
                QUIET=${4:-}
                if [ -z "$SESSION_ID" ]; then
                    error "Missing session ID"
                    echo "Usage: ./ai-dev dev --validate <session_id> [--quiet]"
                    exit 1
                fi
                
                if [ "$QUIET" = "--quiet" ]; then
                    validate_current_progress "$SESSION_ID" "true"
                else
                    validate_current_progress "$SESSION_ID"
                fi
                ;;
                
            --next)
                if [ -z "$SESSION_ID" ]; then
                    error "Missing session ID"
                    echo "Usage: ./ai-dev dev --next <session_id>"
                    exit 1
                fi
                
                get_next_recommended_task "$SESSION_ID"
                ;;
                
            --status)
                if [ -z "$SESSION_ID" ]; then
                    error "Missing session ID"
                    echo "Usage: ./ai-dev dev --status <session_id>"
                    exit 1
                fi
                
                title "📊 Development Status: Session $SESSION_ID"
                
                # Show session state
                current_state=$(get_session_state "$SESSION_ID")
                echo "Current State: $current_state"
                echo ""
                
                # Show progress
                validate_current_progress "$SESSION_ID"
                echo ""
                
                # Show next task
                get_next_recommended_task "$SESSION_ID"
                ;;
                
            --propose)
                TASK_ID=${4:-}
                if [ -z "$SESSION_ID" ] || [ -z "$TASK_ID" ]; then
                    error "Missing required arguments"
                    echo "Usage: ./ai-dev dev --propose <session_id> <task_id>"
                    exit 1
                fi
                
                title "🤖 AI Implementation Proposal: Task $TASK_ID"
                
                tasks_file=$(ls "02_tasks_${SESSION_ID}_"*.md 2>/dev/null | head -1)
                if [ -f "$tasks_file" ]; then
                    # Check if task exists
                    if grep -q "### Task $TASK_ID" "$tasks_file"; then
                        
                        echo "AI analyzes task requirements and proposes implementation approach..."
                        echo ""
                        
                        # Show task summary
                        echo "📋 Task Summary:"
                        grep -A 5 "### Task $TASK_ID" "$tasks_file" | head -6
                        echo ""
                        
                        echo "🤖 AI Proposes:"
                        echo "1. Analysis of task requirements completed"
                        echo "2. Implementation approach determined"
                        echo "3. Required files and structure planned" 
                        echo "4. Security and quality measures identified"
                        echo ""
                        
                        echo "📝 Next Steps:"
                        echo "   Review proposal: ./ai-dev collaborate --preview $SESSION_ID $TASK_ID"
                        echo "   Approve proposal: ./ai-dev dev --approve $SESSION_ID $TASK_ID"
                        echo ""
                        
                        # Record proposal
                        if ! grep -q "<!-- PROPOSED: task=$TASK_ID" "$tasks_file"; then
                            echo "<!-- PROPOSED: task=$TASK_ID timestamp=$(date +%s) -->" >> "$tasks_file"
                            success "Task proposal recorded"
                        else
                            warning "Task already proposed"
                        fi
                        
                    else
                        error "Task $TASK_ID not found"
                        echo "Available tasks:"
                        grep "### Task" "$tasks_file" | head -5
                        exit 1
                    fi
                else
                    error "Tasks file not found for session: $SESSION_ID"
                    exit 1
                fi
                ;;
                
            --approve)
                TASK_ID=${4:-}
                CHANGES=${5:-}
                if [ -z "$SESSION_ID" ] || [ -z "$TASK_ID" ]; then
                    error "Missing required arguments"  
                    echo "Usage: ./ai-dev dev --approve <session_id> <task_id> [--changes \"feedback\"]"
                    exit 1
                fi
                
                title "✅ Developer Approval: Task $TASK_ID"
                
                tasks_file=$(ls "02_tasks_${SESSION_ID}_"*.md 2>/dev/null | head -1)
                if [ -f "$tasks_file" ]; then
                    
                    # Check if task exists
                    if grep -q "### Task $TASK_ID" "$tasks_file"; then
                        
                        # Check if task was proposed
                        if grep -q "<!-- PROPOSED: task=$TASK_ID" "$tasks_file"; then
                            
                            # Handle changes request
                            if [[ "$CHANGES" == "--changes" ]] && [[ -n "${6:-}" ]]; then
                                feedback="${6}"
                                echo "📝 Approval with developer feedback:"
                                echo "   \"$feedback\""
                                echo ""
                                
                                # Record approval with changes
                                echo "<!-- APPROVED: task=$TASK_ID changes=\"$feedback\" timestamp=$(date +%s) -->" >> "$tasks_file"
                                success "Task approved with requested changes"
                                
                                echo ""
                                echo "🤖 AI will adjust implementation based on your feedback"
                                echo "📋 Monitor progress: ./ai-dev dev --status $SESSION_ID"
                                
                            else
                                # Standard approval
                                echo "✅ Task implementation approach approved as proposed"
                                
                                # Record approval
                                echo "<!-- APPROVED: task=$TASK_ID timestamp=$(date +%s) -->" >> "$tasks_file"
                                success "Task approved - AI can proceed with implementation"
                                
                                echo ""
                                echo "📋 Track implementation: ./ai-dev dev --status $SESSION_ID"
                                echo "🔄 Next task: ./ai-dev dev --next $SESSION_ID"
                            fi
                            
                        else
                            warning "Task has not been proposed yet"
                            echo "First run: ./ai-dev dev --propose $SESSION_ID $TASK_ID"
                            exit 1
                        fi
                        
                    else
                        error "Task $TASK_ID not found"
                        exit 1
                    fi
                    
                else
                    error "Tasks file not found for session: $SESSION_ID"
                    exit 1
                fi
                ;;
                
            *)
                error "Unknown dev subcommand: $SUBCOMMAND"
                echo "Available subcommands: --validate, --next, --status, --propose, --approve"
                exit 1
                ;;
        esac
        ;;

    context)
        SUBCOMMAND=${2:-}
        SESSION_ID=${3:-}
        
        case "$SUBCOMMAND" in
            --load)
                if [ -z "$SESSION_ID" ]; then
                    error "Missing session ID"
                    echo "Usage: ./ai-dev context --load <session_id>"
                    exit 1
                fi
                
                title "🧠 Loading Full Context: Session $SESSION_ID"
                load_full_context "$SESSION_ID"
                ;;
                
            --update)
                TASK=${4:-}
                STATUS=${5:-}
                if [ -z "$SESSION_ID" ] || [ -z "$TASK" ] || [ -z "$STATUS" ]; then
                    error "Missing required arguments"
                    echo "Usage: ./ai-dev context --update <session_id> <task> <status>"
                    echo "Status options: in_progress, completed, blocked"
                    exit 1
                fi
                
                update_session_state "$SESSION_ID" "$TASK" "$STATUS"
                ;;
                
            --save)
                if [ -z "$SESSION_ID" ]; then
                    error "Missing session ID"
                    echo "Usage: ./ai-dev context --save <session_id>"
                    exit 1
                fi
                
                save_session_context "$SESSION_ID"
                ;;
                
            --restore)
                if [ -z "$SESSION_ID" ]; then
                    error "Missing session ID"
                    echo "Usage: ./ai-dev context --restore <session_id>"
                    exit 1
                fi
                
                restore_session_context "$SESSION_ID"
                ;;
                
            --compress)
                if [ -z "$SESSION_ID" ]; then
                    error "Missing session ID"
                    echo "Usage: ./ai-dev context --compress <session_id>"
                    exit 1
                fi
                
                compress_large_context "$SESSION_ID"
                ;;
                
            --validate-deps)
                if [ -z "$SESSION_ID" ]; then
                    error "Missing session ID"
                    echo "Usage: ./ai-dev context --validate-deps <session_id>"
                    exit 1
                fi
                
                validate_dependencies "$SESSION_ID"
                ;;
                
            --analyze)
                if [ -z "$SESSION_ID" ]; then
                    error "Missing session ID"
                    echo "Usage: ./ai-dev context --analyze <session_id>"
                    exit 1
                fi
                
                title "🔍 Analyzing Progress vs Plan: Session $SESSION_ID"
                
                # Load context and show analysis
                if load_full_context "$SESSION_ID"; then
                    echo ""
                    validate_current_progress "$SESSION_ID"
                    echo ""
                    
                    tasks_file="$AI_CONTEXT_TASKS"
                    total_tasks=$(grep -c "### Task" "$tasks_file" 2>/dev/null || echo 0)
                    completed_tasks=$(grep -c "✅" "$tasks_file" 2>/dev/null || echo 0)
                    progress_percent=$((completed_tasks * 100 / total_tasks))
                    
                    echo "📈 Progress Analysis:"
                    echo "   Total tasks: $total_tasks"
                    echo "   Completed: $completed_tasks"
                    echo "   Progress: $progress_percent%"
                    
                    if [ $progress_percent -ge 80 ]; then
                        echo "   Status: 🎉 Near completion!"
                    elif [ $progress_percent -ge 50 ]; then
                        echo "   Status: 🚀 Good progress"
                    elif [ $progress_percent -ge 20 ]; then
                        echo "   Status: 🔧 Getting started"
                    else
                        echo "   Status: 🏁 Just beginning"
                    fi
                fi
                ;;
                
            *)
                error "Unknown context subcommand: $SUBCOMMAND"
                echo "Available subcommands: --load, --update, --save, --restore, --compress, --validate-deps, --analyze"
                exit 1
                ;;
        esac
        ;;

    help|--help|-h)
        show_help
        ;;

    version)
        echo "AI Development Framework CLI v3.1.1 (Fixed)"
        echo "Enhanced with AI Supervision + Level 1 Foundation"
        echo "Core: create-prd, generate, execute"
        echo "Collaboration: collaborate, dev, context"
        echo "Level 1: Persistent context, enhanced errors, dependency validation"
        echo "Fixes: Critical errors resolved, improved validation"
        ;;

    doctor|diagnose|check)
        title "🔧 Framework Diagnostic Check"
        
        echo "Running comprehensive framework diagnostic..."
        echo ""
        
        # Environment check
        echo "📋 Environment Validation:"
        validate_environment 2>&1 | sed 's/^/  /'
        echo ""
        
        # File integrity check
        echo "📁 File Integrity:"
        file_issues=0
        for guide in create_prd_guide.md generate_tasks_guide.md execute_tasks_guide.md; do
            if [ -f "$guide" ]; then
                size=$(wc -c < "$guide")
                if [ "$size" -gt 1000 ]; then
                    echo "  ✅ $guide ($size bytes)"
                else
                    echo "  ⚠️  $guide ($size bytes - suspiciously small)"
                    file_issues=$((file_issues + 1))
                fi
            else
                echo "  ❌ $guide (missing)"
                file_issues=$((file_issues + 1))
            fi
        done
        echo ""
        
        # Command functionality check
        echo "🚀 Command Tests:"
        echo "  Testing help command..."
        if ./ai-dev --help >/dev/null 2>&1; then
            echo "  ✅ help: working"
        else
            echo "  ❌ help: failed"
        fi
        
        echo "  Testing status command..."
        if ./ai-dev status >/dev/null 2>&1; then
            echo "  ✅ status: working"
        else
            echo "  ❌ status: failed"
        fi
        
        echo "  Testing projects command..."
        if ./ai-dev projects >/dev/null 2>&1; then
            echo "  ✅ projects: working"
        else
            echo "  ❌ projects: failed"
        fi
        echo ""
        
        # Project state check
        echo "📊 Project Status:"
        prd_count=$(ls 01_prd_*.md 2>/dev/null | wc -l)
        tasks_count=$(ls 02_tasks_*.md 2>/dev/null | wc -l)
        reports_count=$(ls 03_report_*.md 2>/dev/null | wc -l)
        
        echo "  PRD files: $prd_count"
        echo "  Task files: $tasks_count"
        echo "  Report files: $reports_count"
        
        if [ "$prd_count" -gt 0 ]; then
            echo "  ✅ Projects found - framework has been used"
        else
            echo "  ℹ️  No projects yet - run './ai-dev create-prd' to start"
        fi
        echo ""
        
        # Summary
        echo "📋 Diagnostic Summary:"
        if [ "$file_issues" -eq 0 ]; then
            echo "  ✅ All core files present and valid"
            echo "  ✅ Framework appears to be functioning correctly"
            echo "  🎉 Ready for use!"
        else
            echo "  ⚠️  Found $file_issues file issues"
            echo "  🔧 Framework may need repair"
        fi
        echo ""
        echo "For detailed help: ./ai-dev help"
        echo "For project management: ./ai-dev projects"
        ;;

    status)
        title "🔍 Framework Status"
        
        echo "Version: AI Development Framework CLI v3.1.1 (Fixed)"
        echo "Mode: Enhanced Collaboration + Level 1 Foundation (22 commands)"
        echo ""
        
        echo "📁 Directory Structure:"
        echo "  Guide files/            ✅ $(ls *_guide.md 2>/dev/null | wc -l) guide files"
        echo "  PRD files/              ✅ $(ls 01_prd_*.md 2>/dev/null | wc -l) PRD files"
        echo "  Task files/             ✅ $(ls 02_tasks_*.md 2>/dev/null | wc -l) task files"
        echo "  Report files/           ✅ $(ls 03_report_*.md 2>/dev/null | wc -l) report files"
        echo ""
        
        echo "🤖 AI Guides Available:"
        [ -f "create_prd_guide.md" ] && echo "  ✅ PRD Creation Guide" || echo "  ❌ PRD Creation Guide"
        [ -f "generate_tasks_guide.md" ] && echo "  ✅ Task Generation Guide" || echo "  ❌ Task Generation Guide"
        [ -f "execute_tasks_guide.md" ] && echo "  ✅ Execution Guide" || echo "  ❌ Execution Guide"
        echo ""
        
        echo "🔄 Recent Activity:"
        echo "  PRDs Created: $(ls 01_prd_*.md 2>/dev/null | wc -l)"
        echo "  Tasks Generated: $(ls 02_tasks_*.md 2>/dev/null | wc -l)"
        echo "  Last Modified: $(find . -maxdepth 1 -name "*.md" -type f -exec stat -c %y {} \; 2>/dev/null | sort -r | head -1 | cut -d' ' -f1 || echo "None")"
        
        # Show active projects
        echo ""
        echo "📋 Active Projects:"
        if ls 01_prd_*.md >/dev/null 2>&1; then
            for prd in 01_prd_*.md; do
            if [ -f "$prd" ]; then
                session_id=$(echo "$prd" | sed 's/01_prd_\([^_]*\)_.*/\1/')
                project_name=$(echo "$prd" | sed 's/01_prd_[^_]*_\(.*\)\.md/\1/' | tr '-' ' ')
                has_tasks=$([ -f "02_tasks_${session_id}_"*.md ] && echo "✅" || echo "❌")
                has_report=$([ -f "03_report_${session_id}_"*.md ] && echo "✅" || echo "❌")
                echo "  🎯 $session_id: $project_name"
                echo "     PRD: ✅ | Tasks: $has_tasks | Report: $has_report"
            fi
            done
        else
            echo "  No projects found. Create one with: ./ai-dev create-prd"
        fi
        ;;

    projects|list)
        title "📋 Project List"
        
        if ! ls 01_prd_*.md >/dev/null 2>&1; then
            echo "No projects found."
            echo ""
            echo "Create your first project:"
            echo "  ./ai-dev create-prd"
            exit 0
        fi
        
        echo "Active projects in this workspace:"
        echo ""
        
        for prd in 01_prd_*.md; do
            if [ -f "$prd" ]; then
                session_id=$(echo "$prd" | sed 's/01_prd_\([^_]*\)_.*/\1/')
                project_name=$(echo "$prd" | sed 's/01_prd_[^_]*_\(.*\)\.md/\1/' | tr '-' ' ')
                
                # Get project details
                creation_date=$(stat -c %y "$prd" 2>/dev/null | cut -d' ' -f1 || echo "Unknown")
                word_count=$(wc -w < "$prd" 2>/dev/null || echo "0")
                
                # Check project status
                has_tasks=$([ -f "02_tasks_${session_id}_"*.md ] && echo "✅ Generated" || echo "❌ Missing")
                has_report=$([ -f "03_report_${session_id}_"*.md ] && echo "✅ Complete" || echo "❌ Pending")
                
                # Determine project status
                if [ -f "03_report_${session_id}_"*.md ]; then
                    status="🎉 Completed"
                elif [ -f "02_tasks_${session_id}_"*.md ]; then
                    status="🔨 In Development"
                else
                    status="📝 Planning"
                fi
                
                echo "🎯 Session: $session_id"
                echo "   Project: $project_name"
                echo "   Status: $status"
                echo "   Created: $creation_date"
                echo "   PRD: $word_count words"
                echo "   Tasks: $has_tasks"
                echo "   Report: $has_report"
                echo ""
                echo "   Next steps:"
                if [ ! -f "02_tasks_${session_id}_"*.md ]; then
                    echo "   → ./ai-dev generate $prd"
                elif [ ! -f "03_report_${session_id}_"*.md ]; then
                    tasks_file=$(ls "02_tasks_${session_id}_"*.md 2>/dev/null | head -1)
                    echo "   → ./ai-dev execute $(basename "$tasks_file")"
                else
                    echo "   → Project complete! Check report for details."
                fi
                echo ""
                echo "───────────────────────────────────────"
                echo ""
            fi
        done
        ;;

    heal)
        shift
        handle_heal_command "$@"
        ;;

    analyze)
        shift  
        handle_analyze_command "$@"
        ;;

    iterate)
        shift
        handle_iterate_command "$@"
        ;;

    *)
        error "Unknown command: '$COMMAND'"
        echo ""
        echo "Available commands:"
        echo "  Core: create-prd, generate, execute"
        echo "  Collaboration: collaborate, dev, context"
        echo "  Quality: heal, analyze, iterate"
        echo "  System: help, version, status"
        echo ""
        show_help
        exit 1
        ;;
esac

# --- Iterate Command Handler ---
handle_iterate_command() {
    local subcommand="$1"
    local session_id="$2"
    local url="$3"
    
    case "$subcommand" in
        start)
            if [ -z "$session_id" ] || [ -z "$url" ]; then
                error "Missing required arguments"
                echo "Usage: ./ai-dev iterate start <session_id> <url>"
                echo "Example: ./ai-dev iterate start abc123 https://myapp.com"
                exit 1
            fi
            
            title "🔄 Starting Iterative Quality Loop: Session $session_id"
            
            echo "📋 Target: ALL dimensions >= 8/10"
            echo "🔢 Maximum iterations: 5"
            echo "🌐 URL: $url"
            echo ""
            
            # Check if session exists
            if ! ls "*_${session_id}_*.md" >/dev/null 2>&1; then
                error "Session $session_id not found"
                echo "Available sessions:"
                ls 01_prd_*.md 2>/dev/null | sed 's/01_prd_\([^_]*\)_.*/  \1/' | sort -u
                exit 1
            fi
            
            # Load healing guide and start iterative process
            if [ ! -f "ui_healing_guide.md" ]; then
                error "ui_healing_guide.md not found - required for iterative quality system"
                exit 1
            fi
            
            echo "🔍 Initializing iterative quality system..."
            echo "📚 Loading healing standards..."
            echo "🔬 Preparing MCP Context7 integration..."
            
            # This would integrate with the actual iterative system
            execute_ai_guide "ui_healing_guide.md" "Iterative Quality Loop Execution" "$session_id $url"
            ;;
            
        status)
            if [ -z "$session_id" ]; then
                error "Missing session ID"
                echo "Usage: ./ai-dev iterate status <session_id>"
                exit 1
            fi
            
            title "📊 Iterative Quality Status: Session $session_id"
            
            # Check for iteration files
            local iteration_files=$(ls "02_tasks_${session_id}_iteration_"*.md 2>/dev/null | wc -l)
            local quality_report="03_quality_report_${session_id}.md"
            local manual_plan="03_manual_plan_${session_id}.md"
            
            echo "🔄 Iterations completed: $iteration_files"
            
            if [ -f "$quality_report" ]; then
                echo "✅ Status: QUALITY CERTIFIED"
                echo "🏆 Quality report: $quality_report"
                
                # Extract final score if available
                local final_score=$(grep "Final Overall Score:" "$quality_report" 2>/dev/null | head -1)
                if [ -n "$final_score" ]; then
                    echo "📊 $final_score"
                fi
            elif [ -f "$manual_plan" ]; then
                echo "⚠️ Status: REQUIRES MANUAL REVIEW"
                echo "📋 Manual plan: $manual_plan"
            elif [ $iteration_files -gt 0 ]; then
                echo "🔄 Status: IN PROGRESS"
                echo "📈 Latest iteration: $(ls "02_tasks_${session_id}_iteration_"*.md 2>/dev/null | tail -1)"
            else
                echo "❌ Status: NOT STARTED"
                echo "💡 Start with: ./ai-dev iterate start $session_id <url>"
            fi
            ;;
            
        report)
            if [ -z "$session_id" ]; then
                error "Missing session ID"
                echo "Usage: ./ai-dev iterate report <session_id>"
                exit 1
            fi
            
            local quality_report="03_quality_report_${session_id}.md"
            local manual_plan="03_manual_plan_${session_id}.md"
            
            if [ -f "$quality_report" ]; then
                title "🏆 Quality Certification Report: Session $session_id"
                cat "$quality_report"
            elif [ -f "$manual_plan" ]; then
                title "⚠️ Manual Improvement Plan: Session $session_id"
                cat "$manual_plan"
            else
                error "No quality report found for session: $session_id"
                echo "💡 Run quality loop first: ./ai-dev iterate start $session_id <url>"
                exit 1
            fi
            ;;
            
        retry)
            if [ -z "$session_id" ] || [ -z "$url" ]; then
                error "Missing required arguments"
                echo "Usage: ./ai-dev iterate retry <session_id> <url>"
                exit 1
            fi
            
            title "🔄 Retrying Iterative Quality Loop: Session $session_id"
            
            # Clean up previous iteration attempts
            rm -f "02_tasks_${session_id}_iteration_"*.md
            rm -f "03_manual_plan_${session_id}.md"
            
            echo "🧹 Cleaned up previous iteration attempts"
            echo "🔄 Starting fresh iterative quality loop..."
            
            # Restart the iterative process
            execute_ai_guide "ui_healing_guide.md" "Iterative Quality Loop Retry" "$session_id $url"
            ;;
            
        --help|-h)
            cat << 'EOF'
Iterative Quality Loop Commands

Usage: ./ai-dev iterate <subcommand> [arguments]

Subcommands:
  start <session_id> <url>    Start iterative quality improvement loop
  status <session_id>         Show current iteration status
  report <session_id>         Display quality report or manual plan
  retry <session_id> <url>    Clean up and retry quality loop

Examples:
  ./ai-dev iterate start abc123 https://myapp.com
  ./ai-dev iterate status abc123
  ./ai-dev iterate report abc123
  ./ai-dev iterate retry abc123 https://myapp.com

Description:
The iterative quality system replaces traditional single-pass healing with a 
comprehensive loop that continues until ALL dimensions achieve >= 8/10 or 
maximum 5 iterations are reached.

Process:
1. Comprehensive analysis with MCP Context7 research
2. Targeted improvement generation for failing dimensions
3. Automatic improvement application
4. Quality re-assessment
5. Repeat until 8/10+ achieved or manual review required

Quality Dimensions:
- Visual Consistency (20%)
- CRO Optimization (25%)  
- Accessibility (20%)
- Architecture Quality (15%)
- Performance (10%)
- Responsive Design (10%)

Output Files:
- 02_tasks_{session_id}_iteration_{N}.md - Improvement tasks per iteration
- 03_quality_report_{session_id}.md - Success certification report
- 03_manual_plan_{session_id}.md - Manual intervention plan (if needed)
EOF
            ;;
            
        *)
            error "Unknown iterate subcommand: $subcommand"
            echo "Available subcommands: start, status, report, retry"
            echo "For help: ./ai-dev iterate --help"
            exit 1
            ;;
    esac
}

# --- Execute with Mandatory Healing Function ---
execute_with_mandatory_healing() {
    local tasks_file="$1"
    
    # Extraer session ID y project name para traceabilidad
    local session_id=$(echo "$tasks_file" | sed 's/02_tasks_\([^_]*\)_.*/\1/')
    local project_name=$(echo "$tasks_file" | sed 's/02_tasks_[^_]*_\(.*\)\.md/\1/')
    
    if [ -z "$session_id" ] || [ -z "$project_name" ]; then
        error "Could not extract session ID or project name from: $tasks_file"
        return 1
    fi
    
    log "Executing implementation plan: Session $session_id, Project: $project_name"
    
    # Phase 1-5: Ejecutar implementación normal usando la guía
    title "📋 Phases 1-5: Implementation Execution"
    execute_ai_guide "execute_tasks_guide.md" "Executing Implementation Plan (Phases 1-5)" "$tasks_file"
    
    # Phase 6: Mandatory Auto-Healing (Nueva fase obligatoria)
    title "🔍 Phase 6: Mandatory Auto-Healing Quality Validation"
    
    log "CRITICAL: All projects must pass auto-healing validation (8/10 minimum on all dimensions)"
    echo ""
    echo "${BOLD}${YELLOW}Auto-Healing Prerequisites Check:${NC}"
    
    # Verificar prerequisites de healing
    if ! validate_healing_prerequisites_silent; then
        error "❌ Auto-healing prerequisites not met"
        echo ""
        echo "${RED}BLOCKING ISSUE:${NC} Healing validation cannot proceed without:"
        echo "  1. MCP Playwright: ${CYAN}claude mcp add playwright npx '@playwright/mcp@latest'${NC}"
        echo "  2. Healing system files: ui_healing_guide.md, ui_healing_standards.json, cro_optimization_patterns.json"
        echo ""
        echo "📋 Run ${GREEN}./ai-dev heal validate${NC} for detailed setup instructions"
        echo ""
        echo "${BOLD}${RED}PROJECT CANNOT BE COMPLETED WITHOUT HEALING VALIDATION${NC}"
        return 1
    fi
    
    success "✅ Healing prerequisites validated"
    
    # Ejecutar proceso de auto-healing automático
    log "Starting mandatory auto-healing analysis..."
    local healing_result=$(run_mandatory_auto_healing "$session_id" "$project_name")
    
    case "$healing_result" in
        "HEALING_SUCCESS")
            success "🎉 Auto-healing validation PASSED - all dimensions >= 8/10"
            generate_healing_success_report "$session_id" "$project_name"
            success "✅ Project completed successfully with healing validation"
            ;;
        "PENDING_SUPERVISION")
            warning "⚠️  Complex healing changes detected - supervision required"
            echo ""
            echo "${BOLD}${YELLOW}SUPERVISION WORKFLOW ACTIVATED${NC}"
            echo "Complex changes need approval before auto-healing can complete"
            echo ""
            request_healing_supervision "$session_id" "$project_name"
            echo ""
            echo "${GREEN}Next Steps:${NC}"
            echo "1. Review supervision request in: auto_healing_${session_id}.md"
            echo "2. AI will present complex changes for approval"
            echo "3. Choose: Approve, Reject, or Request alternatives"
            echo "4. Auto-healing will complete after approval"
            ;;
        "HEALING_FAILED")
            error "❌ Auto-healing validation FAILED - manual intervention required"
            echo ""
            echo "${BOLD}${RED}HEALING VALIDATION FAILURE${NC}"
            echo "One or more dimensions scored < 8/10 and could not be auto-fixed"
            echo ""
            generate_healing_failure_report "$session_id" "$project_name"
            echo ""
            echo "${RED}🚫 PROJECT BLOCKED - Cannot complete without healing validation${NC}"
            echo "📋 See healing failure report: 03_healing_${session_id}_${project_name}.md"
            echo "🔧 Manual fixes required before project can be marked complete"
            return 1
            ;;
        *)
            error "❌ Unknown healing result: $healing_result"
            return 1
            ;;
    esac
    
    success "🏆 PROJECT COMPLETED WITH MANDATORY HEALING VALIDATION"
    echo ""
    echo "${BOLD}${GREEN}Final Status:${NC}"
    echo "  ✅ Implementation phases 1-5 completed"
    echo "  ✅ Auto-healing validation passed (all dimensions >= 8/10)"
    echo "  ✅ Professional quality standards met"
    echo "  ✅ Production-ready application delivered"
}

validate_healing_prerequisites_silent() {
    # Verificación silenciosa de prerequisites (sin output verbose)
    [ -f "ui_healing_guide.md" ] && \
    [ -f "ui_healing_standards.json" ] && \
    [ -f "cro_optimization_patterns.json" ]
}

run_mandatory_auto_healing() {
    local session_id="$1"
    local project_name="$2"
    
    # Generar template de análisis automático para AI
    local analysis_file="auto_healing_${session_id}.md"
    
    cat > "$analysis_file" << EOF
# Mandatory Auto-Healing Execution Report

**Session ID:** $session_id
**Project:** $project_name
**Analysis Date:** $(date '+%Y-%m-%d %H:%M:%S')
**Mode:** Supervised Auto-Healing (Level 1 + Level 2)
**Framework:** AI Development Framework v3.1.1

---

## 🚨 CRITICAL REQUIREMENTS

**MANDATORY HEALING VALIDATION:**
ALL dimensions must achieve >= 8/10 or project CANNOT be completed.

**Required Files to Load:**
1. ui_healing_guide.md (complete healing instructions and protocols)
2. ui_healing_standards.json (technical standards and scoring matrix)
3. cro_optimization_patterns.json (88 proven CRO patterns)

**Prerequisites Verified:**
✅ MCP Playwright available for automated testing
✅ All healing system files present
✅ Implementation phases 1-5 completed

---

## 🤖 AI EXECUTION PROTOCOL

### Step 1: Automated Analysis
Execute comprehensive healing analysis using MCP Playwright:

**Analysis Dimensions (ALL must score >= 8/10):**
- **Visual Consistency (20% weight)** - Design system adherence
- **CRO Optimization (25% weight)** - Conversion rate optimization  
- **Accessibility (20% weight)** - WCAG 2.1 compliance
- **Architecture Quality (15% weight)** - Code structure quality
- **Performance (10% weight)** - Load times and optimization
- **Responsive Design (10% weight)** - Multi-device support

### Step 2: Intelligent Fix Classification
Automatically categorize required fixes:

**LEVEL 1 - Auto-Apply (No Supervision Required):**
- Accessibility: alt text, ARIA labels, color contrast, heading hierarchy
- Performance: lazy loading, minification, viewport meta, image optimization
- Responsive: touch targets, overflow fixes, mobile navigation
- Visual: color palette, button styles, typography consistency

**LEVEL 2 - Supervision Required:**
- Architecture: component restructuring, API changes, schema modifications
- CRO: layout changes, navigation redesign, form flow modifications
- Performance: code splitting, CDN integration, caching overhauls
- Design: brand modifications, typography systems, component overhauls

### Step 3: Execution Protocol
```javascript
async function executeMandatoryHealing() {
  // 1. Run comprehensive analysis
  const analysis = await runComprehensiveAnalysis();
  
  // 2. Categorize fixes
  const fixes = categorizeFixes(analysis);
  
  // 3. Apply Level 1 fixes automatically
  for (const fix of fixes.level1) {
    await applyAutoFix(fix);
    console.log(\`✅ Auto-applied: \${fix.description}\`);
  }
  
  // 4. Handle Level 2 fixes with supervision
  if (fixes.level2.length > 0) {
    await requestSupervision(fixes.level2);
    return "PENDING_SUPERVISION";
  }
  
  // 5. Final validation
  const finalScores = await runFinalValidation();
  
  if (allDimensionsPass(finalScores)) {
    return "HEALING_SUCCESS";
  } else {
    return "HEALING_FAILED";
  }
}
```

### Step 4: Supervision Protocol (if Level 2 fixes needed)
Generate detailed supervision request with:
- Specific changes proposed with risk assessment
- Before/after comparisons
- Alternative approaches
- Clear approval options (A/B/C/D)

### Step 5: Final Validation
- Re-test all dimensions after fixes
- Verify ALL scores >= 8/10
- Generate completion report

---

## 🚀 BEGIN MANDATORY AUTO-HEALING

**INSTRUCTION:** Execute the complete auto-healing protocol above.

**CRITICAL:** Project cannot be marked complete until ALL dimensions >= 8/10.

**Expected Outputs:**
1. Detailed scoring for each dimension
2. List of fixes applied automatically (Level 1)
3. Supervision request for complex changes (Level 2, if any)
4. Final validation results
5. Success/failure determination

**Note:** If any dimension fails to reach 8/10 after all fixes, mark as HEALING_FAILED with detailed remediation plan.

EOF

    success "Auto-healing template created: $analysis_file"
    echo ""
    echo "${BOLD}${CYAN}Auto-Healing Execution:${NC}"
    echo "1. AI will analyze application using MCP Playwright"
    echo "2. Level 1 fixes applied automatically"
    echo "3. Level 2 fixes require supervision (if any)"
    echo "4. Final validation ensures all dimensions >= 8/10"
    echo ""
    echo "${GREEN}Waiting for AI to complete healing analysis...${NC}"
    
    # En un entorno real, aquí se ejecutaría el análisis
    # Por ahora, retornamos un estado que requiere que la IA procese el archivo
    echo "PENDING_ANALYSIS"
}

generate_healing_success_report() {
    local session_id="$1"
    local project_name="$2"
    local report_file="03_report_${session_id}_${project_name}.md"
    
    cat > "$report_file" << EOF
# Project Completion Report - WITH HEALING VALIDATION

**Project:** $project_name
**Session ID:** $session_id
**Completion Date:** $(date '+%Y-%m-%d %H:%M:%S')
**Framework:** AI Development Framework v3.1.1 Level 1 Foundation

---

## ✅ PROJECT SUCCESSFULLY COMPLETED

### Implementation Summary
- **Phases 1-5:** Core implementation completed successfully
- **Phase 6:** Mandatory auto-healing validation PASSED
- **Quality Standard:** ALL dimensions achieved >= 8/10

### Auto-Healing Validation Results
- ✅ **Visual Consistency:** >= 8/10 (PASSED)
- ✅ **CRO Optimization:** >= 8/10 (PASSED)
- ✅ **Accessibility:** >= 8/10 (PASSED)
- ✅ **Architecture Quality:** >= 8/10 (PASSED)
- ✅ **Performance:** >= 8/10 (PASSED)
- ✅ **Responsive Design:** >= 8/10 (PASSED)

### Healing Fixes Applied
- **Level 1 (Automatic):** [List of auto-applied fixes]
- **Level 2 (Supervised):** [List of approved supervised fixes, if any]

### Final Deliverables
- ✅ Production-ready application
- ✅ Comprehensive documentation
- ✅ Complete test coverage
- ✅ Professional quality standards met
- ✅ GitHub repository with full history

### Next Steps
1. **Deployment:** Application ready for production deployment
2. **Monitoring:** Implement ongoing monitoring and maintenance
3. **Documentation:** All technical documentation available
4. **Support:** Framework provides ongoing support structure

---

## 🏆 QUALITY VALIDATION CERTIFICATE

This project has been validated through the AI Development Framework's mandatory auto-healing process and meets professional industry standards across all quality dimensions.

**Certified by:** AI Development Framework v3.1.1
**Validation Date:** $(date '+%Y-%m-%d')
**Certificate ID:** HEALING-${session_id}-$(date +%s)

EOF

    success "Healing success report generated: $report_file"
}

generate_healing_failure_report() {
    local session_id="$1"
    local project_name="$2"
    local failure_file="03_healing_${session_id}_${project_name}.md"
    
    cat > "$failure_file" << EOF
# Healing Validation Failure Report

**Project:** $project_name
**Session ID:** $session_id
**Analysis Date:** $(date '+%Y-%m-%d %H:%M:%S')
**Status:** HEALING VALIDATION FAILED
**Framework:** AI Development Framework v3.1.1

---

## ❌ HEALING VALIDATION FAILED

**CRITICAL:** Project cannot be completed until ALL dimensions achieve >= 8/10.

### Failed Dimensions
- ❌ **[Dimension]:** X.X/10 (FAILED - requires [type of fixes])
- ❌ **[Dimension]:** X.X/10 (FAILED - requires [type of fixes])

### Issues Identified
[Detailed list of specific issues that prevent achieving 8/10 scores]

### Required Manual Fixes
[Step-by-step remediation plan for each failing dimension]

### Recommended Actions
1. **Immediate:** Address critical issues listed above
2. **Architecture:** Consider refactoring for better maintainability
3. **Performance:** Implement optimization recommendations
4. **Re-validation:** Run healing analysis again after fixes

### Technical Debt Report
[Analysis of accumulated technical debt and prioritized cleanup plan]

---

## 🔧 REMEDIATION WORKFLOW

1. **Fix Issues:** Implement manual fixes listed above
2. **Re-test:** Run \`./ai-dev heal analyze <url>\` again
3. **Validation:** Ensure all dimensions >= 8/10
4. **Completion:** Project can only be marked complete after healing success

**BLOCKING STATUS:** Project remains incomplete until healing validation passes.

EOF

    error "Healing failure report generated: $failure_file"
}

# --- UI/UX Healing System Functions ---
handle_heal_command() {
    local subcommand="$1"
    shift
    
    case "$subcommand" in
        "analyze"|"--analyze")
            local url="$1"
            if [ -z "$url" ]; then
                error "URL required for healing analysis"
                echo "Usage: ./ai-dev heal analyze <url>"
                exit 1
            fi
            
            title "🔍 Starting UI/UX Healing Analysis"
            run_healing_analysis "$url"
            ;;
            
        "report"|"--report")
            local session_id="$1"
            if [ -z "$session_id" ]; then
                error "Session ID required for healing report"
                echo "Usage: ./ai-dev heal report <session_id>"
                exit 1
            fi
            
            generate_healing_report "$session_id"
            ;;
            
        "fix"|"--fix")
            local session_id="$1"
            if [ -z "$session_id" ]; then
                error "Session ID required for applying fixes"
                echo "Usage: ./ai-dev heal fix <session_id>"
                exit 1
            fi
            
            apply_healing_fixes "$session_id"
            ;;
            
        "validate"|"--validate")
            validate_healing_prerequisites
            ;;
            
        *)
            error "Unknown healing subcommand: '$subcommand'"
            echo "Available subcommands:"
            echo "  analyze <url>     - Run comprehensive UI/UX analysis"
            echo "  report <id>       - Generate healing report"
            echo "  fix <id>          - Apply healing fixes"
            echo "  validate          - Check MCP Playwright setup"
            exit 1
            ;;
    esac
}

handle_analyze_command() {
    local subcommand="$1"
    shift
    
    case "$subcommand" in
        "ui"|"--ui")
            local url="$1"
            run_ui_analysis "$url"
            ;;
            
        "performance"|"--performance")
            local url="$1"  
            run_performance_analysis "$url"
            ;;
            
        "accessibility"|"--accessibility")
            local url="$1"
            run_accessibility_analysis "$url"
            ;;
            
        "cro"|"--cro")
            local url="$1"
            run_cro_analysis "$url"
            ;;
            
        *)
            error "Unknown analyze subcommand: '$subcommand'"
            echo "Available subcommands:"
            echo "  ui <url>             - Visual consistency analysis"
            echo "  performance <url>    - Performance and optimization"
            echo "  accessibility <url>  - A11y compliance testing"
            echo "  cro <url>           - Conversion optimization analysis"
            exit 1
            ;;
    esac
}

validate_healing_prerequisites() {
    title "🛠️ Validating UI/UX Healing Prerequisites"
    
    log "Checking MCP Playwright installation..."
    
    # Check if healing guide files exist
    if [ ! -f "ui_healing_guide.md" ]; then
        error "ui_healing_guide.md not found - healing system not available"
        return 1
    fi
    
    if [ ! -f "ui_healing_standards.json" ]; then
        error "ui_healing_standards.json not found - standards not available"
        return 1
    fi
    
    if [ ! -f "cro_optimization_patterns.json" ]; then
        error "cro_optimization_patterns.json not found - CRO patterns not available"
        return 1
    fi
    
    success "All healing system files present"
    
    # Instructions for MCP Playwright setup
    echo ""
    echo "${BOLD}${YELLOW}MCP Playwright Setup Required:${NC}"
    echo "To enable automated UI analysis, install MCP Playwright:"
    echo ""
    echo "${CYAN}claude mcp add playwright npx '@playwright/mcp@latest'${NC}"
    echo ""
    echo "Additional recommended MCPs:"
    echo "${CYAN}claude mcp add web-scraper${NC}     # For content analysis"
    echo "${CYAN}claude mcp add lighthouse${NC}      # For performance auditing"
    echo ""
    echo "After installation, use:"
    echo "${GREEN}./ai-dev heal analyze <url>${NC}    # Full healing analysis"
    echo "${GREEN}./ai-dev analyze ui <url>${NC}      # Specific dimension analysis"
    
    return 0
}

run_healing_analysis() {
    local url="$1"
    
    if [ -z "$url" ]; then
        error "URL required for healing analysis"
        echo "Usage: ./ai-dev heal analyze <url>"
        return 1
    fi
    
    log "Starting comprehensive UI/UX healing analysis for: $url"
    
    # Generate unique session ID for this analysis
    local session_id=$(date +%s | tail -c 6)
    local analysis_file="healing_analysis_${session_id}.md"
    
    # Create analysis report header
    cat > "$analysis_file" << EOF
# UI/UX Healing Analysis Report

**URL Analyzed:** $url  
**Analysis Date:** $(date '+%Y-%m-%d %H:%M:%S')  
**Session ID:** $session_id  
**Framework Version:** v3.1.1 Level 1 Foundation

---

## 🚨 CRITICAL REQUIREMENT
All dimensions must score >= 8/10 for approval.

## 📋 Analysis Instructions for AI

**PREREQUISITE:** Ensure MCP Playwright is installed:
\`\`\`bash
claude mcp add playwright npx '@playwright/mcp@latest'
\`\`\`

**Required Files:**
- Load ui_healing_guide.md (complete instructions)
- Load ui_healing_standards.json (technical standards)  
- Load cro_optimization_patterns.json (CRO patterns)

**Analysis Protocol:**
1. Follow automated analysis protocol in ui_healing_guide.md
2. Use MCP Playwright for automated testing and screenshots
3. Apply scoring matrix from ui_healing_standards.json
4. Research current best practices using MCP Context7
5. Generate both recommendations AND executable code fixes

**Dimensions to Analyze:**
- Visual Consistency (20% weight) - Design system adherence
- CRO Optimization (25% weight) - Conversion rate optimization
- Accessibility (20% weight) - WCAG 2.1 compliance
- Architecture Quality (15% weight) - Code structure quality
- Performance (10% weight) - Load times and optimization
- Responsive Design (10% weight) - Multi-device support

**Output Required:**
- Detailed scoring for each dimension (1-10)
- Specific issues identified with evidence
- Executable code fixes for all issues < 8/10
- A/B testing recommendations for CRO improvements
- Implementation timeline with priorities

---

## 🤖 AI: Begin Analysis Here

Use MCP Playwright to analyze: $url

Follow the complete protocol in ui_healing_guide.md for automated analysis.

EOF

    success "Healing analysis template created: $analysis_file"
    echo ""
    echo "${BOLD}${CYAN}Next Steps:${NC}"
    echo "1. Open the analysis file: $analysis_file"
    echo "2. Provide this file to an AI with MCP Playwright installed"
    echo "3. The AI will perform automated analysis and generate fixes"
    echo "4. Use ${GREEN}./ai-dev heal report $session_id${NC} to view results"
    
    log "Analysis session $session_id created successfully"
    return 0
}

run_ui_analysis() {
    local url="$1"
    
    if [ -z "$url" ]; then
        error "URL required for UI analysis"
        echo "Usage: ./ai-dev analyze ui <url>"
        return 1
    fi
    
    log "Starting visual consistency analysis for: $url"
    echo "This requires MCP Playwright integration with AI"
    echo "See: ./ai-dev heal validate for setup instructions"
}

run_performance_analysis() {
    local url="$1"
    
    if [ -z "$url" ]; then
        error "URL required for performance analysis"
        echo "Usage: ./ai-dev analyze performance <url>"
        return 1
    fi
    
    log "Starting performance analysis for: $url"
    echo "This requires MCP Playwright + Lighthouse integration"
    echo "See: ./ai-dev heal validate for setup instructions"
}

run_accessibility_analysis() {
    local url="$1"
    
    if [ -z "$url" ]; then
        error "URL required for accessibility analysis"
        echo "Usage: ./ai-dev analyze accessibility <url>"
        return 1
    fi
    
    log "Starting accessibility analysis for: $url"
    echo "This requires MCP Playwright + axe-core integration"
    echo "See: ./ai-dev heal validate for setup instructions"
}

run_cro_analysis() {
    local url="$1"
    
    if [ -z "$url" ]; then
        error "URL required for CRO analysis"
        echo "Usage: ./ai-dev analyze cro <url>"
        return 1
    fi
    
    log "Starting CRO pattern analysis for: $url"
    echo "This uses 88 proven CRO patterns from cro_optimization_patterns.json"
    echo "See: ./ai-dev heal validate for setup instructions"
}

generate_healing_report() {
    local session_id="$1"
    
    local analysis_file="healing_analysis_${session_id}.md"
    
    if [ ! -f "$analysis_file" ]; then
        error "Analysis file not found: $analysis_file"
        echo "Run './ai-dev heal analyze <url>' first"
        return 1
    fi
    
    success "Healing analysis report: $analysis_file"
    echo "File contains AI analysis results and generated fixes"
}

apply_healing_fixes() {
    local session_id="$1"
    
    log "Healing fixes application requires manual review of generated code"
    echo "Review fixes in: healing_analysis_${session_id}.md"
    echo "Apply fixes manually after validation"
}

# Log successful execution
log "Command completed successfully: $COMMAND"
exit 0