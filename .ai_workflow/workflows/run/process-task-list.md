# Process Task List

## Purpose
Executes structured task lists generated from PRDs, managing dependencies, progress tracking, and ensuring proper validation at each step. This workflow orchestrates the execution of multiple related tasks in sequence.

## When to Use
- Executing task lists generated from PRDs
- Managing complex multi-task implementations
- Coordinating dependencies between related tasks
- Tracking progress across large development initiatives

## Objective
Process a structured task list file, execute tasks in proper dependency order, track progress, and ensure validation criteria are met for each completed task.

## Pre-conditions
- Valid task list file exists (typically generated by `generate-tasks.md`)
- Framework is properly initialized
- Required dependencies and tools are available
- Task list follows framework's structured format

## Commands
```bash
# Validate task list file exists
if [ -z "$TASK_LIST_FILE" ]; then
    echo "ERROR: TASK_LIST_FILE parameter required"
    ./.ai_workflow/workflows/common/error.md "Task list file path not provided"
    exit 1
fi

if [ ! -f "$TASK_LIST_FILE" ]; then
    echo "ERROR: Task list file not found at: $TASK_LIST_FILE"
    ./.ai_workflow/workflows/common/error.md "Task list file does not exist: $TASK_LIST_FILE"
    exit 1
fi

# Log workflow start
./.ai_workflow/workflows/common/log_work_journal.md "INFO" "Starting task list processing: $TASK_LIST_FILE"

# Initialize progress tracking
PROGRESS_DIR=".ai_workflow/state/task_progress"
mkdir -p "$PROGRESS_DIR"

PROJECT_NAME=$(basename "$TASK_LIST_FILE" .md | sed 's/_tasks$//')
PROGRESS_FILE="$PROGRESS_DIR/${PROJECT_NAME}_progress.json"
SESSION_LOG="$PROGRESS_DIR/${PROJECT_NAME}_session.log"

# Create initial progress file if it doesn't exist
if [ ! -f "$PROGRESS_FILE" ]; then
    cat > "$PROGRESS_FILE" << EOF
{
  "project": "$PROJECT_NAME",
  "task_list_file": "$TASK_LIST_FILE",
  "started": "$(date -Iseconds)",
  "status": "in_progress",
  "completed_tasks": [],
  "failed_tasks": [],
  "current_phase": "Phase 1",
  "total_tasks": 0,
  "completed_count": 0
}
EOF
fi

# Extract task information from the file
echo "📋 Analyzing task list structure..."
TOTAL_TASKS=$(grep -c "^- \[ \]" "$TASK_LIST_FILE" || echo "0")

# Update total task count
python3 -c "
import json
import sys
try:
    with open('$PROGRESS_FILE', 'r') as f:
        data = json.load(f)
    data['total_tasks'] = $TOTAL_TASKS
    with open('$PROGRESS_FILE', 'w') as f:
        json.dump(data, f, indent=2)
except Exception as e:
    print(f'Warning: Could not update progress file: {e}', file=sys.stderr)
"

echo "📊 Found $TOTAL_TASKS tasks to process"
echo "🗓️  Session log: $SESSION_LOG"

# Function to update task progress
update_progress() {
    local task_id="$1"
    local status="$2"
    local message="$3"
    
    echo "$(date '+%Y-%m-%d %H:%M:%S') [$status] $task_id: $message" >> "$SESSION_LOG"
    
    python3 -c "
import json
import sys
try:
    with open('$PROGRESS_FILE', 'r') as f:
        data = json.load(f)
    
    if '$status' == 'completed':
        if '$task_id' not in data['completed_tasks']:
            data['completed_tasks'].append('$task_id')
            data['completed_count'] = len(data['completed_tasks'])
    elif '$status' == 'failed':
        if '$task_id' not in data['failed_tasks']:
            data['failed_tasks'].append('$task_id')
    
    data['last_updated'] = '$(date -Iseconds)'
    
    with open('$PROGRESS_FILE', 'w') as f:
        json.dump(data, f, indent=2)
except Exception as e:
    print(f'Warning: Could not update progress: {e}', file=sys.stderr)
"
}

# Function to check if task can be executed (dependencies met)
check_dependencies() {
    local task_id="$1"
    local deps_line=$(grep -A 3 "**$task_id**" "$TASK_LIST_FILE" | grep "Dependencies:" | head -1)
    
    if echo "$deps_line" | grep -q "None"; then
        return 0  # No dependencies
    fi
    
    # Extract dependency IDs and check if they're completed
    local deps=$(echo "$deps_line" | sed 's/.*Dependencies: *//' | tr ',' ' ')
    
    for dep in $deps; do
        dep=$(echo "$dep" | xargs)  # trim whitespace
        if ! grep -q "\"$dep\"" "$PROGRESS_FILE" 2>/dev/null; then
            echo "⏳ Task $task_id waiting for dependency: $dep"
            return 1  # Dependency not met
        fi
    done
    
    return 0  # All dependencies met
}

# Function to execute a single task
execute_task() {
    local task_id="$1"
    local task_line="$2"
    
    echo ""
    echo "🔧 Executing Task: $task_id"
    echo "📝 Description: $task_line"
    
    # Check dependencies
    if ! check_dependencies "$task_id"; then
        echo "⏸️  Task $task_id skipped - dependencies not met"
        return 1
    fi
    
    update_progress "$task_id" "started" "Task execution started"
    
    # Extract validation criteria
    local validation=$(grep -A 10 "**$task_id**" "$TASK_LIST_FILE" | grep "Validation:" | head -1 | sed 's/.*Validation: *//')
    
    echo "🎯 Validation Criteria: $validation"
    echo ""
    
    # Use environment variable or interactive execution
    if [ "$AUTO_CONFIRM" = "true" ]; then
        echo "🤖 Auto-confirmation enabled - proceeding with task execution"
        task_result="completed"
    else
        echo "Execute this task? [y/n/s(kip)]: "
        read -r execute_choice
        
        case "$execute_choice" in
            y|Y|yes|YES)
                echo "✅ Task marked as completed"
                task_result="completed"
                ;;
            s|S|skip|SKIP)
                echo "⏭️  Task skipped by user"
                task_result="skipped"
                ;;
            *)
                echo "❌ Task execution cancelled"
                task_result="cancelled"
                ;;
        esac
    fi
    
    # Update progress based on result
    case "$task_result" in
        completed)
            update_progress "$task_id" "completed" "Task completed successfully"
            # Mark task as done in the file (if writable)
            if [ -w "$TASK_LIST_FILE" ]; then
                sed -i "s/- \[ \] \*\*$task_id\*\*/- [x] **$task_id**/" "$TASK_LIST_FILE"
            fi
            echo "✅ Task $task_id completed and marked"
            return 0
            ;;
        skipped)
            update_progress "$task_id" "skipped" "Task skipped by user"
            echo "⏭️  Task $task_id skipped"
            return 1
            ;;
        *)
            update_progress "$task_id" "failed" "Task execution failed or cancelled"
            echo "❌ Task $task_id failed"
            return 1
            ;;
    esac
}

# Main processing loop
echo ""
echo "🚀 Starting task execution..."
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

# Extract tasks and process them
TASK_COUNT=0
COMPLETED_COUNT=0
FAILED_COUNT=0

# Process tasks by extracting them from the file
while IFS= read -r line; do
    if echo "$line" | grep -q "^- \[ \] \*\*T[0-9]*\*\*"; then
        # Extract task ID
        TASK_ID=$(echo "$line" | sed 's/.*\*\*\(T[0-9]*\)\*\*.*/\1/')
        TASK_COUNT=$((TASK_COUNT + 1))
        
        echo ""
        echo "📍 Processing task $TASK_COUNT of $TOTAL_TASKS"
        
        if execute_task "$TASK_ID" "$line"; then
            COMPLETED_COUNT=$((COMPLETED_COUNT + 1))
        else
            FAILED_COUNT=$((FAILED_COUNT + 1))
        fi
        
        # Show progress
        echo "📊 Progress: $COMPLETED_COUNT completed, $FAILED_COUNT failed/skipped, $((TOTAL_TASKS - COMPLETED_COUNT - FAILED_COUNT)) remaining"
        
        # Optional pause between tasks
        if [ "$AUTO_CONFIRM" != "true" ] && [ $TASK_COUNT -lt $TOTAL_TASKS ]; then
            echo ""
            echo "Continue to next task? [y/n]: "
            read -r continue_choice
            if [ "$continue_choice" != "y" ] && [ "$continue_choice" != "Y" ]; then
                echo "🛑 Task processing stopped by user"
                break
            fi
        fi
    fi
done < "$TASK_LIST_FILE"

# Final summary
echo ""
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo "📊 Task Processing Summary"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo "📋 Total tasks: $TOTAL_TASKS"
echo "✅ Completed: $COMPLETED_COUNT"
echo "❌ Failed/Skipped: $FAILED_COUNT"
echo "⏳ Remaining: $((TOTAL_TASKS - COMPLETED_COUNT - FAILED_COUNT))"
echo ""
echo "📄 Session log: $SESSION_LOG"
echo "📊 Progress file: $PROGRESS_FILE"

# Update final status
if [ $COMPLETED_COUNT -eq $TOTAL_TASKS ]; then
    FINAL_STATUS="completed"
    echo "🎉 All tasks completed successfully!"
elif [ $COMPLETED_COUNT -gt 0 ]; then
    FINAL_STATUS="partial"
    echo "⚠️  Task list partially completed"
else
    FINAL_STATUS="failed"
    echo "❌ No tasks were completed"
fi

# Update final progress
python3 -c "
import json
try:
    with open('$PROGRESS_FILE', 'r') as f:
        data = json.load(f)
    data['status'] = '$FINAL_STATUS'
    data['completed'] = '$(date -Iseconds)'
    data['final_summary'] = {
        'total_tasks': $TOTAL_TASKS,
        'completed_count': $COMPLETED_COUNT,
        'failed_count': $FAILED_COUNT
    }
    with open('$PROGRESS_FILE', 'w') as f:
        json.dump(data, f, indent=2)
except Exception as e:
    print(f'Warning: Could not update final progress: {e}', file=sys.stderr)
"

# Log completion
./.ai_workflow/workflows/common/log_work_journal.md "INFO" "Task list processing completed: $FINAL_STATUS ($COMPLETED_COUNT/$TOTAL_TASKS tasks)"

# Set exit code based on results
if [ "$FINAL_STATUS" = "completed" ]; then
    exit 0
else
    exit 1
fi
```

## Verification Criteria
- Task list file is successfully parsed
- Dependencies are properly checked before task execution
- Progress is tracked and persisted throughout execution
- Session logs are maintained for audit trail
- Final summary shows accurate completion statistics

## Input Parameters
- `TASK_LIST_FILE`: Path to the structured task list file (required)
- `AUTO_CONFIRM`: Set to "true" for automated execution without prompts (optional)

## Output
- Progress tracking files in `.ai_workflow/state/task_progress/`
- Session logs with detailed execution history
- Updated task list file with completed tasks marked
- Final execution summary and statistics

## Next Steps
- **On Success:** Proceed to [Review and Refactor](../common/review-and-refactor.md) for quality assurance
- **On Partial Completion:** Review failed tasks and retry or create specific PRPs
- **On Failure:** Proceed to [Generic Error Handler](../common/error.md)

## Related Workflows
- [Generate Tasks](../prd/generate-tasks.md) - Create task lists from PRDs
- [Review and Refactor](../common/review-and-refactor.md) - Quality assurance workflow
- [Create PRP](../prp/01_create_prp.md) - Create detailed PRPs for complex tasks